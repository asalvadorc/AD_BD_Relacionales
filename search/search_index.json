{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement CompartirIgual 2.5","title":"Acc\u00e9s a Dades - Fitxers"},{"location":"1__les_bases_de_dades_relacionals/","text":"1 - Les Bases de Dades Relacionals \u00b6 Els Sistemes Gestors de Bases de Dades Relacionals es basen en el Model Relacional (com el seu nom indica), \u00e9s a dir en taules interrelacionades entre elles, i han demostrat la seua solidesa per a guardar la informaci\u00f3 al llarg dels anys. Recordem que el primer producte comercial seri\u00f3s d'aquest tipus, Oracle, va apar\u00e9ixer en 1979. Alguna cosa tindr\u00e0, per tant, per a haver aguantat tants anys. Segurament \u00e9s perqu\u00e8 es tracta d\u2019una tecnologia senzilla per\u00f2 molt eficient. I que a m\u00e9s ha sabut adaptar-se a la major part de sistemes de dades que les empreses reclamaven i a un cost prou assequible. Per\u00f2 no tot s\u00f3n avantatges en el Model Relacional. T\u00e9 limitacions importants, per exemple a l\u2019hora de representar informaci\u00f3 poc estructurada, o per a estructures excessivament din\u00e0miques i complexes. Fins i tot semblava que anava a substituir-se aquest model per altres, com el Model Orientat a Objectes. Per\u00f2 aquesta substituci\u00f3 o canvi no acaba d\u2019arribar. La principal ra\u00f3 la trobem en la solidesa i maduresa que tenen els Sistemes Gestors de Bases de Dades Relacionals. De fet, molts autors apunten cap a una evoluci\u00f3 dels Sistemes Relacionals incorporant eines i tecnologies que els apropen al model Orientat a Objectes (com veurem en el Tema 6) m\u00e9s que no cap a la seua desaparici\u00f3 i substituci\u00f3. Per tant, s'imposa el seu estudi. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement CompartirIgual 2.5","title":"1 - Les Bases de Dades Relacionals"},{"location":"1__les_bases_de_dades_relacionals/#1-les-bases-de-dades-relacionals","text":"Els Sistemes Gestors de Bases de Dades Relacionals es basen en el Model Relacional (com el seu nom indica), \u00e9s a dir en taules interrelacionades entre elles, i han demostrat la seua solidesa per a guardar la informaci\u00f3 al llarg dels anys. Recordem que el primer producte comercial seri\u00f3s d'aquest tipus, Oracle, va apar\u00e9ixer en 1979. Alguna cosa tindr\u00e0, per tant, per a haver aguantat tants anys. Segurament \u00e9s perqu\u00e8 es tracta d\u2019una tecnologia senzilla per\u00f2 molt eficient. I que a m\u00e9s ha sabut adaptar-se a la major part de sistemes de dades que les empreses reclamaven i a un cost prou assequible. Per\u00f2 no tot s\u00f3n avantatges en el Model Relacional. T\u00e9 limitacions importants, per exemple a l\u2019hora de representar informaci\u00f3 poc estructurada, o per a estructures excessivament din\u00e0miques i complexes. Fins i tot semblava que anava a substituir-se aquest model per altres, com el Model Orientat a Objectes. Per\u00f2 aquesta substituci\u00f3 o canvi no acaba d\u2019arribar. La principal ra\u00f3 la trobem en la solidesa i maduresa que tenen els Sistemes Gestors de Bases de Dades Relacionals. De fet, molts autors apunten cap a una evoluci\u00f3 dels Sistemes Relacionals incorporant eines i tecnologies que els apropen al model Orientat a Objectes (com veurem en el Tema 6) m\u00e9s que no cap a la seua desaparici\u00f3 i substituci\u00f3. Per tant, s'imposa el seu estudi. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement CompartirIgual 2.5","title":"1 - Les Bases de Dades Relacionals"},{"location":"2__el_desfasament_objecterelacional/","text":"2 - El desfasament Objecte-Relacional \u00b6 Quan necessitem explicar o plasmar una realitat complexa, en compte d'intentar guardar-la directament, \u00e9s molt convenient utilitzar un model conceptual m\u00e9s proper a nosaltres que es comporte de forma similar a la realitat. Es tracta de plasmar els aspectes essencials i, a la vegada, alleugerir els detalls insignificants per tal de poder rebaixar la complexitat, i representar-lo d'una manera propera a nosaltres. La utilitzaci\u00f3 de models conceptuals durant la implementaci\u00f3 d\u2019aplicacions inform\u00e0tiques \u00e9s d\u2019una import\u00e0ncia extrema per poder portar a bon termini qualsevol projecte d\u2019informatitzaci\u00f3. El problema \u00e9s que els models conceptuals s\u00f3n representacions mentals creats a base d\u2019un proc\u00e9s d\u2019abstracci\u00f3. I no hi ha una \u00fanica forma de plasmar-los o representar-los. Moltes vegades fem servir aproximacions esquem\u00e0tiques que poden estar molt prop de la representaci\u00f3 mental, per\u00f2 fins i tot les representacions esquem\u00e0tiques s\u00f3n dif\u00edcilment representables en la mem\u00f2ria d\u2019un ordinador. En el cas dels Sistemes Gestors de Bases de Dades Relacionals, primer intentem representar-lo per mig del Model Entitat-Relaci\u00f3 (que seria el model conceptual que ens permet fer l'aproximaci\u00f3 esquem\u00e0tica), i despr\u00e9s tradu\u00efm aquest al Model Relacional (a les taules). Com veurem despr\u00e9s, el Model Orientat a Objectes intenta representar la realitat per mig d'objectes i les interactuacions que poden haver entre ells. Per tant \u00e9s un altre model conceptual per a intentar representar la mateixa realitat. Ens trobem per tant davant de dues maneres de representar la informaci\u00f3, i inevitablement hi haur\u00e0 un desfasament. Perqu\u00e8 en les nostres aplicacions utilitzarem objectes, mentre que en el Model Relacional (on volem guardar la informaci\u00f3) s'utilitzen taules. Intentarem explicar aquest desfasament amb uns exemples. El Model Relacional \u00b6 El Model Relacional es basa en les taules. En una taula tindrem en les columnes els distints atributs o caracter\u00edstiques que volem representar, i en les files els distints individus d'aquesta taula. En totes les taules considerem que tenim una clau principal que identifica un\u00edvocament l'individu. En l'exemple el camp codi ser\u00e0 la clau principal, que identifica un\u00edvocament cada editorial. Les diferents taules poden estar relacionades. Si per exemple ens guardem tamb\u00e9 els llibres, veur\u00edem que les editorials i els llibres estan relacionades, concretament un llibre l'ha editat una editorial. Per a marcar aquest fet el Model Relacional utilitza les claus externes ( foreign keys ). Una clau externa \u00e9s un camp que en una altra taula \u00e9s clau principal (la que identifica un\u00edvocament). D'aquesta manera, en la taula LLIBRE posarem un camp (per exemple editorial ) el contingut del qual ser\u00e0 el codi, qui identifica en l'altra taula, i d'aquesta manera representarem perfectament l'editorial a la qual pertany el llibre. Completem un poc m\u00e9s l'exemple anterior, registrant tamb\u00e9 els autors dels llibres. Recordem que un llibre pot tenir m\u00e9s d'un autor i un autor pot haver fet m\u00e9s d'un llibre. Com coment\u00e0vem anteriorment, el primer que s'hauria de fer per tenir un bon disseny \u00e9s l'esquema en el Model Entitat-Relaci\u00f3 , i despr\u00e9s traduir-lo al Model Relacional. Que vol dir que una editorial pot tenir molts llibres editats (per\u00f2 un llibre nom\u00e9s est\u00e0 editat per una editorial). I un llibre pot ser escrit per m\u00e9s d'un autor, el qual a la seua vegada pot escriure molts llibres. La traducci\u00f3 al Model Relacional ens donaria no 3 taules, sin\u00f3 4. A m\u00e9s de les taules EDITORIAL , LLIBRE i AUTOR , ens fa falta una altra taula, anomenada per exemple AUTOR_LLIBRE , que \u00e9s el resultat de la relaci\u00f3 M:N entre AUTOR i LLIBRE . Aquest seria l'esquema del Model Relacional: on hem indicat les claus principals en negreta, i les claus externes amb un doble subratllat i una fletxa apuntant a la clau principal de l'altra taula. Observeu que la clau principal de AUTOR_LLIBRE \u00e9s cod_a + isbn . A m\u00e9s cadascuna d'elles \u00e9s tamb\u00e9 clau externa que apunta a la taula corresponent. El Model Relacional tamb\u00e9 permet definir un conjunt de regles i limitacions en els valors de les dades i en les accions a realitzar, amb l\u2019objectiu d\u2019assegurar la consist\u00e8ncia de les dades. Aix\u00ed, \u00e9s possible indicar qu\u00e8 s'ha de fer amb els registres d\u2019una taula que es troben vinculats al registre d\u2019una segona taula en el moment d\u2019eliminar-lo d'aquesta segona taula. Per exemple, si eliminem l'autor aut83 de la taula d'autors, qu\u00e8 fem amb les files de la taula AUTOR_LLIBRE**** que tenen aquest autor? Doncs tres serien les possibilitats: NO ACTION , \u00e9s a dir, no fer l'acci\u00f3 (no esborrar aut83) CASCADE , \u00e9s a dir, esborrar tamb\u00e9 les files de AUTOR_LLIBRE en les que estiga aut83. SET NULL , \u00e9s a dir posar a nul el camp en la taula vinculada, per\u00f2 en el nostre exemple aquest ultim cas no \u00e9s possible, perqu\u00e8 cod_a forma part de la clau principal, i per definici\u00f3 cap camp de la clau principal pot agafar el valor nul. En el cas d'esborrar un autor, a priori sembla que l'opci\u00f3 m\u00e9s correcta seria la primera, \u00e9s a dir, no poder esborrar un autor del qual tenim algun llibre (i per tant tenim alguna fila en la taula AUTOR_LLIBRE amb aquest autor). Per\u00f2 en cada cas s'ha de mirar quina \u00e9s l'opci\u00f3 m\u00e9s adequada. Aix\u00ed per exemple, segurament si esborrem un llibre, podr\u00edem perfectament esborrar autom\u00e0ticament de la taula AUTOR-LLIBRE les files d'aquest llibre (per\u00f2 no esborrar de la taula AUTOR, clar). El Model Relacional tamb\u00e9 permet altres restriccions, com per exemple: definir el rang o conjunt de valors possibles que un camp d\u2019una taula podr\u00e0 agafar (el que s'anomena com a domini ), definir un camp com a no nul (per exemple podr\u00edem exigir que el camp nom de la taula AUTOR no puga agafar el valor nul) assegurar la no repetici\u00f3 de determinats camps en diferents registres d\u2019una mateixa taula (per exemple que no es puga repetir el camp nom de la taula EDITORIAL, ja que suposaria tenir dues editorials que es diuen exactament igual). Model Orientat a Objectes \u00b6 El Model Orientat a Objectes \u00e9s un altre model conceptual que t\u00e9 un punt de vista diferent al Model Entitat-Relaci\u00f3. Els objectes poden representar qualsevol element del model conceptual, una entitat, una caracter\u00edstica, un proc\u00e9s, una acci\u00f3, una relaci\u00f3\u2026 En els objectes no \u00fanicament intentarem representar les caracter\u00edstiques importants (dades), sin\u00f3 que tamb\u00e9 vodrem fer refer\u00e8ncia al comportament o la funcionalitat que tindran en el moment de materialitzar-se durant l\u2019execuci\u00f3 de les aplicacions (codi). \u00c9s a dir, que en un objecte es guarden tant les dades com les operacions (m\u00e8todes) que fem amb aquestes dades, tot junt. La import\u00e0ncia de centrar el model en els objectes \u00e9s m\u00faltiple. Ente els avantages estan: En refer\u00e8ncia a les dades, els objectes actuen com estructures jer\u00e0rquiques, de manera que la informaci\u00f3 queda sempre perfectament contextualitzada dins dels objectes. Aix\u00ed, no t\u00e9 sentit referir-nos a una variable solta. Per exemple, en una aplicaci\u00f3 d'una biblioteca el n\u00famero de p\u00e0gines d'un llibre estar\u00e0 sempre associat (i contingut) a un objecte llibre; igual que el t\u00edtol, isbn i la resta de dades significatives. Podr\u00edem pensar que \u00e9s igual que en les taules, on els camps o atributs pertanyen a una taula. La difer\u00e8ncia, per\u00f2, es troba en el fet que en el Model Relacional nom\u00e9s es mant\u00e9 aquesta relaci\u00f3 dins la taula, mentre que en el Model Orientat a Objectes aquesta relaci\u00f3 s\u2019est\u00e9n a tota l\u2019aplicaci\u00f3 incorporant-la en el propi codi d\u2019execuci\u00f3. En refer\u00e8ncia al comportament o la funcionalitat, els objectes delimiten les accions a realitzar sobre les seues dades i sobre la resta d\u2019objectes, definint les regles del joc del que es pot fer durant l\u2019execuci\u00f3 de les aplicacions. El seg\u00fcent dibuix s'intenta explicar aquesta manera de funcionar: Les figures circulars representen objectes de diferents tipus segons el color. En el centre dels objectes, els petits cercles representen les dades encapsulades, inaccessibles de forma directa. Les corones circulars exteriors representen els m\u00e8todes, els quals a petici\u00f3 d\u2019altres objectes (fletxes) poden consultar o manipular l\u2019estat de l\u2019objecte. Per\u00f2 des de fora no es poden tocar directament les dades, sempre ha de ser a trav\u00e9s dels m\u00e8todes que ofereix l'objecte. Els valors del conjunt de dades que conformen un objecte en un moment determinat s\u2019anomena tamb\u00e9 estat , perqu\u00e8 permet descriure l\u2019evoluci\u00f3 de qualsevol objecte durant l\u2019execuci\u00f3 d\u2019una aplicaci\u00f3, des del moment de la seua creaci\u00f3 fins que siguen eliminats de la mem\u00f2ria. Per tant, els estats dels objectes aniran variant al llarg de l'aplicaci\u00f3. Malauradament, el Model conceptual Orientat a Objectes \u00e9s un model eminentment din\u00e0mic que no contempla , a priori, la persist\u00e8ncia dels seus objectes . Per tant s'ha d'aconseguir poder guardar de forma permanent els estats dels objectes. S'haur\u00e0 de portar des d'on estan guardats els objectes al principi de l'aplicaci\u00f3, inicialitzant-los en l\u2019estat en qu\u00e8 es trobaven quan es van guardar. Tamb\u00e9 s'haur\u00e0 d'anar guardant peri\u00f2dicament l\u2019estat dels objectes a mida que es vagen produint els canvis, de manera que hi haja sempre una correspond\u00e8ncia entre els objectes en mem\u00f2ria i els seus estats emmagatzemats. Si pensem en objectes, l'exemple anterior de la biblioteca podria quedar aix\u00ed (no hem posat els m\u00e8todes de cada classe, per centrar-nos en les dades): Cosa que ens duria a les seg\u00fcents classes: En aquest exemple, per simplificar, \u00fanicament hem plasmat les relacions entre classes a la classe Llibre , posant la refer\u00e8ncia a l'objecte Editorial al qual pertany el llibre, i un ArrayList d'Autors , on estar\u00e0 la llista dels autors del llibre. En realitat, per a una major comoditat a l'hora de programar, el m\u00e9s l\u00f2gic seria posar tamb\u00e9 en Editorial un ArrayList que arreplegue tots els llibres de l'editorial, i en Autor posar\u00edem un ArrayList amb tots els llibres de l'autor. Per\u00f2 no les hem posades per fer l'exemple m\u00e9s senzill. El Desfasament Objecte-Relacional \u00b6 Si ens plantegem guardar els objectes d\u2019una aplicaci\u00f3 en un SGBD Relacional , el principal problema que trobarem \u00e9s que es tracta de conceptes diferents, els objectes i les taules, i estan centrats en aspectes tamb\u00e9 diferents. El Model Entitat-Relaci\u00f3 (que tindr\u00e0 una traducci\u00f3 directa al Model Relacional) es troba fortament centrat en les dades i en l\u2019estructura que cal donar a aquestes dades per poder guardar-les i recuperar-les. En canvi el Model Orientat a Objectes es troba centrat en els objectes, entesos com a agrupacions de dades i tamb\u00e9 com a un conjunt de processos de canvi, que afecten aquestes dades. El Model Relacional necessitar\u00e0 sempre certa quantitat d\u2019informaci\u00f3 extra destinada a mantenir les relacions i la coher\u00e8ncia de les dades. Les claus externes s\u00f3n l\u2019exemple m\u00e9s clar. Es tracta d\u2019informaci\u00f3 afegida en alguns registres per tal de vincular-los a uns altres. Aix\u00ed per exemple, per a saber el llibre de quina editorial \u00e9s, afegim la clau externa que apunte a la taula Editorial, que ser\u00e0 un camp en la taula Llibre on es guardar\u00e0 la clau principal de l'editorial a la qual pertany (per aix\u00f2 es diu clau externa). La vinculaci\u00f3 entre objectes, en canvi, s\u2019aconsegueix de forma estructural. No es necessiten dades extra, sin\u00f3 que la mateixa estructura de dades defineix la vinculaci\u00f3, la visibilitat, l\u2019acc\u00e9s, etc. Per exemple, per a guardar l'editorial d'un llibre, no guardem la seua clau principal com una clau externa en el llibre, sin\u00f3 que guardem una refer\u00e8ncia a la mateixa editorial, a l'objecte editorial. Aquestes difer\u00e8ncies constitueixen el que en el m\u00f3n de la programaci\u00f3 es coneix com a desfasament objecte-relacional . Aquest desfasament ens obliga, quan decidim treballar conjuntament amb els dos models, un SGBD Relacional per a guardar les dades i un llenguatge Orientat a Objectes com per exemple Java o Kotlin, a codificar implementacions extres que funcionen a mode d\u2019adaptadors. \u00c9s a dir que hem de convertir o transformar els objectes en taules i a l'inrev\u00e9s. Mirem l'exemple comentat tant en el Model Relacional com en l'Orientat a Objectes: la biblioteca. Hi ha evidents difer\u00e8ncies en guardar les coses d'una o altra manera. Les difer\u00e8ncies m\u00e9s clares s\u00f3n: La manera d'indicar l'editorial del llibre, en objectes \u00e9s posar una refer\u00e8ncia a l'editorial, mentre que en el Model Relacional posem una clau externa. Quan anem a guardar les dades, s'haur\u00e0 de substituir l'objecte editorial per la clau principal de l'editorial. I quan recuperem, ser\u00e0 el proc\u00e9s invers, haur\u00edem d'utilitzar la clau externa per agafar l'editorial i guardar aquest objecte en l'objecte llibre. M\u00e9s complicada \u00e9s la manera d'indicar els autors del llibre. Com pot haver m\u00e9s d'un autor per llibre, en objectes posem un ArrayList de tipus Autor, mentre que en el Model Relacional hem de posar una nova taula. Guardar les dades d'un llibre suposar\u00e0 en la pr\u00e0ctica guardar en dues taules, LLIBRE i AUTOR_LLIBRE. Les dades de LLIBRE es poden guardar directament, i les de AUTOR_LLIBRE suposar\u00e0 un bucle per a rec\u00f3rrer l'ArrayList i fer una operaci\u00f3 d'escriptura (INSERT) en AUTOR_LLIBRE per cada autor de la llista. A l'inrev\u00e8s tamb\u00e9 haurem de fer un bucle, recorrent totes les files dels autors del llibre en q\u00fcesti\u00f3, per a anar inserint en l'ArrayList. Tamb\u00e9 haurem de tenir present que el Model Relacional disposa d\u2019un conjunt de llenguatges (DDL, DCL, SQL, etc.) adequats per explotar al m\u00e0xim els SGBD tenint en compte les caracter\u00edstiques relacionals, i aix\u00ed poder crear les taules (CREATE TABLE), inserir les dades (INSERT) i recuperar-les (SELECT), mentre que en la programaci\u00f3 Orientada a Objectes es treballa b\u00e0sicament amb llenguatges de programaci\u00f3 imperatius. Haurem d'incorporar per tant les sent\u00e8ncies de SQL (i DDL, ...) dins del llenguatge amfitri\u00f3 orientat a objectes (per exemple Java o Kotlin). Un altre exemple de desfasament el trobem tamb\u00e9 en els resultats recuperats des d\u2019un SGBD. Aquestos s\u2019obtenen sempre en un format tabular i, per tant, caldr\u00e0 implementar utilitats que transformen les seq\u00fc\u00e8ncies de dades simples en estats dels objectes de l\u2019aplicaci\u00f3, com hav\u00edem vist en l'exemple de la biblioteca. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement CompartirIgual 2.5","title":"2 - El desfasament Objecte-Relacional"},{"location":"2__el_desfasament_objecterelacional/#2-el-desfasament-objecte-relacional","text":"Quan necessitem explicar o plasmar una realitat complexa, en compte d'intentar guardar-la directament, \u00e9s molt convenient utilitzar un model conceptual m\u00e9s proper a nosaltres que es comporte de forma similar a la realitat. Es tracta de plasmar els aspectes essencials i, a la vegada, alleugerir els detalls insignificants per tal de poder rebaixar la complexitat, i representar-lo d'una manera propera a nosaltres. La utilitzaci\u00f3 de models conceptuals durant la implementaci\u00f3 d\u2019aplicacions inform\u00e0tiques \u00e9s d\u2019una import\u00e0ncia extrema per poder portar a bon termini qualsevol projecte d\u2019informatitzaci\u00f3. El problema \u00e9s que els models conceptuals s\u00f3n representacions mentals creats a base d\u2019un proc\u00e9s d\u2019abstracci\u00f3. I no hi ha una \u00fanica forma de plasmar-los o representar-los. Moltes vegades fem servir aproximacions esquem\u00e0tiques que poden estar molt prop de la representaci\u00f3 mental, per\u00f2 fins i tot les representacions esquem\u00e0tiques s\u00f3n dif\u00edcilment representables en la mem\u00f2ria d\u2019un ordinador. En el cas dels Sistemes Gestors de Bases de Dades Relacionals, primer intentem representar-lo per mig del Model Entitat-Relaci\u00f3 (que seria el model conceptual que ens permet fer l'aproximaci\u00f3 esquem\u00e0tica), i despr\u00e9s tradu\u00efm aquest al Model Relacional (a les taules). Com veurem despr\u00e9s, el Model Orientat a Objectes intenta representar la realitat per mig d'objectes i les interactuacions que poden haver entre ells. Per tant \u00e9s un altre model conceptual per a intentar representar la mateixa realitat. Ens trobem per tant davant de dues maneres de representar la informaci\u00f3, i inevitablement hi haur\u00e0 un desfasament. Perqu\u00e8 en les nostres aplicacions utilitzarem objectes, mentre que en el Model Relacional (on volem guardar la informaci\u00f3) s'utilitzen taules. Intentarem explicar aquest desfasament amb uns exemples.","title":"2 - El desfasament Objecte-Relacional"},{"location":"2__el_desfasament_objecterelacional/#el-model-relacional","text":"El Model Relacional es basa en les taules. En una taula tindrem en les columnes els distints atributs o caracter\u00edstiques que volem representar, i en les files els distints individus d'aquesta taula. En totes les taules considerem que tenim una clau principal que identifica un\u00edvocament l'individu. En l'exemple el camp codi ser\u00e0 la clau principal, que identifica un\u00edvocament cada editorial. Les diferents taules poden estar relacionades. Si per exemple ens guardem tamb\u00e9 els llibres, veur\u00edem que les editorials i els llibres estan relacionades, concretament un llibre l'ha editat una editorial. Per a marcar aquest fet el Model Relacional utilitza les claus externes ( foreign keys ). Una clau externa \u00e9s un camp que en una altra taula \u00e9s clau principal (la que identifica un\u00edvocament). D'aquesta manera, en la taula LLIBRE posarem un camp (per exemple editorial ) el contingut del qual ser\u00e0 el codi, qui identifica en l'altra taula, i d'aquesta manera representarem perfectament l'editorial a la qual pertany el llibre. Completem un poc m\u00e9s l'exemple anterior, registrant tamb\u00e9 els autors dels llibres. Recordem que un llibre pot tenir m\u00e9s d'un autor i un autor pot haver fet m\u00e9s d'un llibre. Com coment\u00e0vem anteriorment, el primer que s'hauria de fer per tenir un bon disseny \u00e9s l'esquema en el Model Entitat-Relaci\u00f3 , i despr\u00e9s traduir-lo al Model Relacional. Que vol dir que una editorial pot tenir molts llibres editats (per\u00f2 un llibre nom\u00e9s est\u00e0 editat per una editorial). I un llibre pot ser escrit per m\u00e9s d'un autor, el qual a la seua vegada pot escriure molts llibres. La traducci\u00f3 al Model Relacional ens donaria no 3 taules, sin\u00f3 4. A m\u00e9s de les taules EDITORIAL , LLIBRE i AUTOR , ens fa falta una altra taula, anomenada per exemple AUTOR_LLIBRE , que \u00e9s el resultat de la relaci\u00f3 M:N entre AUTOR i LLIBRE . Aquest seria l'esquema del Model Relacional: on hem indicat les claus principals en negreta, i les claus externes amb un doble subratllat i una fletxa apuntant a la clau principal de l'altra taula. Observeu que la clau principal de AUTOR_LLIBRE \u00e9s cod_a + isbn . A m\u00e9s cadascuna d'elles \u00e9s tamb\u00e9 clau externa que apunta a la taula corresponent. El Model Relacional tamb\u00e9 permet definir un conjunt de regles i limitacions en els valors de les dades i en les accions a realitzar, amb l\u2019objectiu d\u2019assegurar la consist\u00e8ncia de les dades. Aix\u00ed, \u00e9s possible indicar qu\u00e8 s'ha de fer amb els registres d\u2019una taula que es troben vinculats al registre d\u2019una segona taula en el moment d\u2019eliminar-lo d'aquesta segona taula. Per exemple, si eliminem l'autor aut83 de la taula d'autors, qu\u00e8 fem amb les files de la taula AUTOR_LLIBRE**** que tenen aquest autor? Doncs tres serien les possibilitats: NO ACTION , \u00e9s a dir, no fer l'acci\u00f3 (no esborrar aut83) CASCADE , \u00e9s a dir, esborrar tamb\u00e9 les files de AUTOR_LLIBRE en les que estiga aut83. SET NULL , \u00e9s a dir posar a nul el camp en la taula vinculada, per\u00f2 en el nostre exemple aquest ultim cas no \u00e9s possible, perqu\u00e8 cod_a forma part de la clau principal, i per definici\u00f3 cap camp de la clau principal pot agafar el valor nul. En el cas d'esborrar un autor, a priori sembla que l'opci\u00f3 m\u00e9s correcta seria la primera, \u00e9s a dir, no poder esborrar un autor del qual tenim algun llibre (i per tant tenim alguna fila en la taula AUTOR_LLIBRE amb aquest autor). Per\u00f2 en cada cas s'ha de mirar quina \u00e9s l'opci\u00f3 m\u00e9s adequada. Aix\u00ed per exemple, segurament si esborrem un llibre, podr\u00edem perfectament esborrar autom\u00e0ticament de la taula AUTOR-LLIBRE les files d'aquest llibre (per\u00f2 no esborrar de la taula AUTOR, clar). El Model Relacional tamb\u00e9 permet altres restriccions, com per exemple: definir el rang o conjunt de valors possibles que un camp d\u2019una taula podr\u00e0 agafar (el que s'anomena com a domini ), definir un camp com a no nul (per exemple podr\u00edem exigir que el camp nom de la taula AUTOR no puga agafar el valor nul) assegurar la no repetici\u00f3 de determinats camps en diferents registres d\u2019una mateixa taula (per exemple que no es puga repetir el camp nom de la taula EDITORIAL, ja que suposaria tenir dues editorials que es diuen exactament igual).","title":"El Model Relacional"},{"location":"2__el_desfasament_objecterelacional/#model-orientat-a-objectes","text":"El Model Orientat a Objectes \u00e9s un altre model conceptual que t\u00e9 un punt de vista diferent al Model Entitat-Relaci\u00f3. Els objectes poden representar qualsevol element del model conceptual, una entitat, una caracter\u00edstica, un proc\u00e9s, una acci\u00f3, una relaci\u00f3\u2026 En els objectes no \u00fanicament intentarem representar les caracter\u00edstiques importants (dades), sin\u00f3 que tamb\u00e9 vodrem fer refer\u00e8ncia al comportament o la funcionalitat que tindran en el moment de materialitzar-se durant l\u2019execuci\u00f3 de les aplicacions (codi). \u00c9s a dir, que en un objecte es guarden tant les dades com les operacions (m\u00e8todes) que fem amb aquestes dades, tot junt. La import\u00e0ncia de centrar el model en els objectes \u00e9s m\u00faltiple. Ente els avantages estan: En refer\u00e8ncia a les dades, els objectes actuen com estructures jer\u00e0rquiques, de manera que la informaci\u00f3 queda sempre perfectament contextualitzada dins dels objectes. Aix\u00ed, no t\u00e9 sentit referir-nos a una variable solta. Per exemple, en una aplicaci\u00f3 d'una biblioteca el n\u00famero de p\u00e0gines d'un llibre estar\u00e0 sempre associat (i contingut) a un objecte llibre; igual que el t\u00edtol, isbn i la resta de dades significatives. Podr\u00edem pensar que \u00e9s igual que en les taules, on els camps o atributs pertanyen a una taula. La difer\u00e8ncia, per\u00f2, es troba en el fet que en el Model Relacional nom\u00e9s es mant\u00e9 aquesta relaci\u00f3 dins la taula, mentre que en el Model Orientat a Objectes aquesta relaci\u00f3 s\u2019est\u00e9n a tota l\u2019aplicaci\u00f3 incorporant-la en el propi codi d\u2019execuci\u00f3. En refer\u00e8ncia al comportament o la funcionalitat, els objectes delimiten les accions a realitzar sobre les seues dades i sobre la resta d\u2019objectes, definint les regles del joc del que es pot fer durant l\u2019execuci\u00f3 de les aplicacions. El seg\u00fcent dibuix s'intenta explicar aquesta manera de funcionar: Les figures circulars representen objectes de diferents tipus segons el color. En el centre dels objectes, els petits cercles representen les dades encapsulades, inaccessibles de forma directa. Les corones circulars exteriors representen els m\u00e8todes, els quals a petici\u00f3 d\u2019altres objectes (fletxes) poden consultar o manipular l\u2019estat de l\u2019objecte. Per\u00f2 des de fora no es poden tocar directament les dades, sempre ha de ser a trav\u00e9s dels m\u00e8todes que ofereix l'objecte. Els valors del conjunt de dades que conformen un objecte en un moment determinat s\u2019anomena tamb\u00e9 estat , perqu\u00e8 permet descriure l\u2019evoluci\u00f3 de qualsevol objecte durant l\u2019execuci\u00f3 d\u2019una aplicaci\u00f3, des del moment de la seua creaci\u00f3 fins que siguen eliminats de la mem\u00f2ria. Per tant, els estats dels objectes aniran variant al llarg de l'aplicaci\u00f3. Malauradament, el Model conceptual Orientat a Objectes \u00e9s un model eminentment din\u00e0mic que no contempla , a priori, la persist\u00e8ncia dels seus objectes . Per tant s'ha d'aconseguir poder guardar de forma permanent els estats dels objectes. S'haur\u00e0 de portar des d'on estan guardats els objectes al principi de l'aplicaci\u00f3, inicialitzant-los en l\u2019estat en qu\u00e8 es trobaven quan es van guardar. Tamb\u00e9 s'haur\u00e0 d'anar guardant peri\u00f2dicament l\u2019estat dels objectes a mida que es vagen produint els canvis, de manera que hi haja sempre una correspond\u00e8ncia entre els objectes en mem\u00f2ria i els seus estats emmagatzemats. Si pensem en objectes, l'exemple anterior de la biblioteca podria quedar aix\u00ed (no hem posat els m\u00e8todes de cada classe, per centrar-nos en les dades): Cosa que ens duria a les seg\u00fcents classes: En aquest exemple, per simplificar, \u00fanicament hem plasmat les relacions entre classes a la classe Llibre , posant la refer\u00e8ncia a l'objecte Editorial al qual pertany el llibre, i un ArrayList d'Autors , on estar\u00e0 la llista dels autors del llibre. En realitat, per a una major comoditat a l'hora de programar, el m\u00e9s l\u00f2gic seria posar tamb\u00e9 en Editorial un ArrayList que arreplegue tots els llibres de l'editorial, i en Autor posar\u00edem un ArrayList amb tots els llibres de l'autor. Per\u00f2 no les hem posades per fer l'exemple m\u00e9s senzill.","title":"Model Orientat a Objectes"},{"location":"2__el_desfasament_objecterelacional/#el-desfasament-objecte-relacional","text":"Si ens plantegem guardar els objectes d\u2019una aplicaci\u00f3 en un SGBD Relacional , el principal problema que trobarem \u00e9s que es tracta de conceptes diferents, els objectes i les taules, i estan centrats en aspectes tamb\u00e9 diferents. El Model Entitat-Relaci\u00f3 (que tindr\u00e0 una traducci\u00f3 directa al Model Relacional) es troba fortament centrat en les dades i en l\u2019estructura que cal donar a aquestes dades per poder guardar-les i recuperar-les. En canvi el Model Orientat a Objectes es troba centrat en els objectes, entesos com a agrupacions de dades i tamb\u00e9 com a un conjunt de processos de canvi, que afecten aquestes dades. El Model Relacional necessitar\u00e0 sempre certa quantitat d\u2019informaci\u00f3 extra destinada a mantenir les relacions i la coher\u00e8ncia de les dades. Les claus externes s\u00f3n l\u2019exemple m\u00e9s clar. Es tracta d\u2019informaci\u00f3 afegida en alguns registres per tal de vincular-los a uns altres. Aix\u00ed per exemple, per a saber el llibre de quina editorial \u00e9s, afegim la clau externa que apunte a la taula Editorial, que ser\u00e0 un camp en la taula Llibre on es guardar\u00e0 la clau principal de l'editorial a la qual pertany (per aix\u00f2 es diu clau externa). La vinculaci\u00f3 entre objectes, en canvi, s\u2019aconsegueix de forma estructural. No es necessiten dades extra, sin\u00f3 que la mateixa estructura de dades defineix la vinculaci\u00f3, la visibilitat, l\u2019acc\u00e9s, etc. Per exemple, per a guardar l'editorial d'un llibre, no guardem la seua clau principal com una clau externa en el llibre, sin\u00f3 que guardem una refer\u00e8ncia a la mateixa editorial, a l'objecte editorial. Aquestes difer\u00e8ncies constitueixen el que en el m\u00f3n de la programaci\u00f3 es coneix com a desfasament objecte-relacional . Aquest desfasament ens obliga, quan decidim treballar conjuntament amb els dos models, un SGBD Relacional per a guardar les dades i un llenguatge Orientat a Objectes com per exemple Java o Kotlin, a codificar implementacions extres que funcionen a mode d\u2019adaptadors. \u00c9s a dir que hem de convertir o transformar els objectes en taules i a l'inrev\u00e9s. Mirem l'exemple comentat tant en el Model Relacional com en l'Orientat a Objectes: la biblioteca. Hi ha evidents difer\u00e8ncies en guardar les coses d'una o altra manera. Les difer\u00e8ncies m\u00e9s clares s\u00f3n: La manera d'indicar l'editorial del llibre, en objectes \u00e9s posar una refer\u00e8ncia a l'editorial, mentre que en el Model Relacional posem una clau externa. Quan anem a guardar les dades, s'haur\u00e0 de substituir l'objecte editorial per la clau principal de l'editorial. I quan recuperem, ser\u00e0 el proc\u00e9s invers, haur\u00edem d'utilitzar la clau externa per agafar l'editorial i guardar aquest objecte en l'objecte llibre. M\u00e9s complicada \u00e9s la manera d'indicar els autors del llibre. Com pot haver m\u00e9s d'un autor per llibre, en objectes posem un ArrayList de tipus Autor, mentre que en el Model Relacional hem de posar una nova taula. Guardar les dades d'un llibre suposar\u00e0 en la pr\u00e0ctica guardar en dues taules, LLIBRE i AUTOR_LLIBRE. Les dades de LLIBRE es poden guardar directament, i les de AUTOR_LLIBRE suposar\u00e0 un bucle per a rec\u00f3rrer l'ArrayList i fer una operaci\u00f3 d'escriptura (INSERT) en AUTOR_LLIBRE per cada autor de la llista. A l'inrev\u00e8s tamb\u00e9 haurem de fer un bucle, recorrent totes les files dels autors del llibre en q\u00fcesti\u00f3, per a anar inserint en l'ArrayList. Tamb\u00e9 haurem de tenir present que el Model Relacional disposa d\u2019un conjunt de llenguatges (DDL, DCL, SQL, etc.) adequats per explotar al m\u00e0xim els SGBD tenint en compte les caracter\u00edstiques relacionals, i aix\u00ed poder crear les taules (CREATE TABLE), inserir les dades (INSERT) i recuperar-les (SELECT), mentre que en la programaci\u00f3 Orientada a Objectes es treballa b\u00e0sicament amb llenguatges de programaci\u00f3 imperatius. Haurem d'incorporar per tant les sent\u00e8ncies de SQL (i DDL, ...) dins del llenguatge amfitri\u00f3 orientat a objectes (per exemple Java o Kotlin). Un altre exemple de desfasament el trobem tamb\u00e9 en els resultats recuperats des d\u2019un SGBD. Aquestos s\u2019obtenen sempre en un format tabular i, per tant, caldr\u00e0 implementar utilitats que transformen les seq\u00fc\u00e8ncies de dades simples en estats dels objectes de l\u2019aplicaci\u00f3, com hav\u00edem vist en l'exemple de la biblioteca. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement CompartirIgual 2.5","title":"El Desfasament Objecte-Relacional"},{"location":"3__connexi_a_les_bd_connectors/","text":"3 - Connexi\u00f3 a les BD: Connectors \u00b6 Deixem de banda de moment el desfasament Objecte-Relacional i centrem-nos ara en l'acc\u00e9s a Base de Dades Relacionals des dels llenguatges de programaci\u00f3. Ho raonarem en general i ho aplicarem a Java-Kotlin. Des de la d\u00e8cada dels 80 que existeixen a ple rendiment les Bases de Dades Relacionals. Quasi tots els Sistemes Gestors de Bases de Dades (excepte els m\u00e9s xicotets com Access, Base de LibreOffice o SQLite) utilitzen l'arquitectura client-servidor. Aix\u00f2 vol dir que hi ha un ordinador central on est\u00e0 instal\u00b7lat el Sistema Gestor de Bases de Dades Relacional que actua com a servidor, i hi haur\u00e0 molts clients que es connectaran al servidor fent peticions sobre la Base de Dades. Els Sistemes Gestors de Bases de Dades inicialment disposaven de llenguatges de programaci\u00f3 propis per a poder fer els accesos des dels clients. Era molt consistent, per\u00f2 a base de ser molt poc operatiu: L'empresa desenvolupadora del SGBD havia de mantenir un llenguatge de programaci\u00f3, que resultava necess\u00e0riament molt cost\u00f3s, si no volien que quedara desfasat. Les empreses usu\u00e0ries del SGBD, que es connectaven com a clients, es trobaven molt lligades al servidor per haver d'utilitzar el llenguatge de programaci\u00f3 per accedir al servidor, cosa que no sempre s'ajustava a les seues necessitats. A m\u00e9s, el plantejar-se canviar de servidor, volia dir que s'havien de re-fer tots els programes, i per tant una tasca de molt\u00edssima envergadura. Per a poder ser m\u00e9s operatius, calia desvincular els llenguatges de programaci\u00f3 dels Sistemes Gestors de Bases de Dades utilitzant uns est\u00e0ndars de connexi\u00f3. 3.1 - ODBC \u00b6 A mida que les teories de dades relacionals anaven agafant for\u00e7a i les xarxes guanyaven adeptes gr\u00e0cies a l\u2019increment de l\u2019efici\u00e8ncia a preus realment competitius, van comen\u00e7ar a implementar-se uns Sistemes Gestors de Bases de Dades basats en la tecnologia client-servidor, que van triomfar. La tecnologia client-servidor va permetre a\u00efllar les dades i els programes espec\u00edfics d\u2019acc\u00e9s a aquestes dades, del desenvolupament de l\u2019aplicaci\u00f3. La ra\u00f3 principal d\u2019aquesta divisi\u00f3 va ser segurament possibilitar l\u2019acc\u00e9s remot a les dades de qualsevol ordinador connectat a la xarxa. El cert, per\u00f2, \u00e9s que aquest fet va emp\u00e8nyer els Sistemes de Bases de Dades a desenvolupar-se d\u2019una forma a\u00efllada i a crear protocols i llenguatges espec\u00edfics per poder-se comunicar remotament amb les aplicacions que corrien en els clients. Per dir- lo d'alguna manera, havien de desenvolupar els servidors i tamb\u00e9 els clients, per a poder connectar-se amb el servidor. A poc a poc, el software al voltant de les bases de dades va cr\u00e9ixer espectacularment intentant donar resposta a un m\u00e0xim de demandes a trav\u00e9s de sistemes altament configurables. \u00c9s el que avui dia es coneix com a middleware o capa interm\u00e8dia de persist\u00e8ncia. \u00c9s a dir, el conjunt d\u2019aplicacions, utilitats, biblioteques, protocols i llenguatges, situats tant a la part servidor com a la part client, que permeten connectar-se remotament a una base de dades per configurar-la o explotar-ne les seues dades. L'arribada dels est\u00e0ndards Inicialment, cada empresa desenvolupadora d\u2019un SGBD implementava les seues solucions espec\u00edfiques per al seu sistema, per\u00f2 prompte es van donar compte que col\u00b7laborant conjuntament podien treure\u2019n major rendiment i avan\u00e7ar molt m\u00e9s r\u00e0pidament. Sostenint-se en el Model Relacional i en algunes implementacions primerenques de les empreses IBM i Oracle, es va desenvolupar el llenguatge de consulta de dades anomenat SQL ( Structured Query Language ). Va ser un gran pas endavant, perqu\u00e8 s'uniformava la manera d'accedir a la BD, per\u00f2 les aplicacions necessitaven API amb funcions que permeteren fer crides des del llenguatge de desenvolupament per enviar les consultes SQL. Cada SGBD t\u00e9 la seua pr\u00f2pia connexi\u00f3 i el seu propi API. El grup anomenat SQL Access Group , en el qual participaven prestigioses empreses del sector com Oracle, Informix, Ingres, DEC, Sun o HP, va definir un API universal amb independ\u00e8ncia del llenguatge de desenvolupament i la Base de Dades a connectar. El 1992, Microsoft i Simba implementen l\u2019 ODBC ( Open Data Base Connectivity ), un API basat en la definici\u00f3 del SQL Acces Group , que s\u2019integra en el sistema operatiu de Windows i que permet afegir m\u00faltiples connectors (o controladors o Drivers ) a diverses Bases de Dades Relacionals (que utilitzen SQL) de forma molt senzilla i transparent, ja que els connectors s\u00f3n autoinstal\u00b7lables i totalment configurables des de les mateixes eines del Sistema Operatiu. D'aquesta manera, tenint instal\u00b7lat ODBC (i en Windows acabar\u00e0 venint instal\u00b7lat per defecte), les aplicacions es connectaran a trav\u00e9s d'ODBC a qualsevol dels SGBD del qual tinguem instal\u00b7lat el connector. Per a connectar a una Base de Dades o una altra, nom\u00e9s hem de canviar de controlador, sense haver de canviar la pr\u00f2pia aplicaci\u00f3. L\u2019arribada de l\u2019ODBC va representar un pas sense precedents en el cam\u00ed cap a la interoperabilitat entre bases de dades i llenguatges de programaci\u00f3. La majoria d\u2019empreses desenvolupadores de Sistemes Gestors de Bases de Dades van proporcionar els drivers de connectivitat, i els llenguatges de programaci\u00f3 m\u00e9s importants van desenvolupar biblioteques espec\u00edfiques per suportar l\u2019API ODBC. La situaci\u00f3 actual Actualment, ODBC continua sent una adequada manera de connectar als SGDB Relacionals. El seu desenvolupament segueix liderat per Microsoft, per\u00f2 existeixen versions per a altres Sistemes Operatius com UNIX/LINUX o MAC. Els llenguatges m\u00e9s populars de desenvolupament mantenen actualitzades les biblioteques de comunicaci\u00f3 amb les successives versions que han anat apareixent i la majoria de SGBD disposen d\u2019un controlador ODBC b\u00e0sic. I per tant la connexi\u00f3 queda garantida. Actualment, l\u2019ODBC s\u2019estructura en tres nivells. El primer, anomenat core API , \u00e9s el nivell m\u00e9s b\u00e0sic corresponent a l\u2019especificaci\u00f3 original (basada en el SQL Access Group ). El Level 1 API i el Level 2 API afegeixen funcionalitats avan\u00e7ades, com cridades a procediments guardats en el Sistema Gestor de Bases de Dades, aspectes de seguretat d\u2019acc\u00e9s, definici\u00f3 de tipus estructurats, etc. En realitat, l\u2019ODBC \u00e9s una especificaci\u00f3 de baix nivell, \u00e9s a dir, de funcions b\u00e0siques que possibiliten la connexi\u00f3, que asseguren l\u2019atomicitat de les peticions, el retorn d\u2019informaci\u00f3, el capsulament del llenguatge de consulta SQL o l\u2019obtenci\u00f3 de dades aconseguides en resposta a un petici\u00f3. La funcionalitat de baix nivell fa que es puga adaptar a moltes aplicacions; aix\u00f2 s\u00ed, a costa d\u2019un considerable nombre de l\u00ednies de codi necess\u00e0ries per adaptar-se a la l\u00f2gica de cada aplicaci\u00f3. \u00c9s per aix\u00f2 que sobre la base de l\u2019ODBC han sorgit altres alternatives de persist\u00e8ncia de m\u00e9s alt nivell. Per exemple, Microsoft ha desenvolupat OLE DB o ADO.NET. Aquest \u00faltim possibilita ja els objectes per a qualsevol tipus d\u2019aplicaci\u00f3 basada en la plataforma .NET. 3.2 - JDBC \u00b6 Pr\u00e0cticament de forma simult\u00e0nia a ODBC, l\u2019empresa Sun Microsystems, l\u2019any 1997 va treure a la llum JDBC ( Java DataBase Connectivity ), un API connector de bases de dades, implementat espec\u00edficament per a utilitzar amb el llenguatge Java. Es tracta d\u2019un API molt similar a ODBC quant a la manera de funcionar: Tindrem l'API JDBC que utilitzaran les aplicacions que vulguen connectar a les Bases de Dades, i que garatitza una uniformitat, siga quina siga la o les Bases de Dades a connectar Ens far\u00e0 falta un controlador o driver per cada Base de Dades a la qual vulguem connectar Per\u00f2 com coment\u00e0vem, est\u00e0 adaptat espec\u00edficament per a Java. \u00c9s a dir, la funcionalitat es troba encapsulada en classes (ja que Java \u00e9s un llenguatge totalment orientat a objectes) i a m\u00e9s, no dep\u00e8n de cap plataforma especifica, d\u2019acord amb la caracter\u00edstica multiplataforma defensada per Java. Aquest connector ser\u00e0 l\u2019API que estudiarem en detall en aquesta unitat, ja que Java no disposa de cap biblioteca espec\u00edfica ODBC. Les raons esgrimides per Sun s\u00f3n que ODBC no es pot fer servir directament en Java ja que est\u00e0 implementat en C i no \u00e9s orientat a objectes. Per\u00f2, per a no perdre la potencialitat de les connexions ODBC, que recordem que ens permetia connectar a qualsevol Base de Dades Relacional, Sun Microsystem ha optat per incorporar de s\u00e8rie un driver especial que actua d\u2019adaptador entre l\u2019especificaci\u00f3 JDBC i l\u2019especificaci\u00f3 ODBC. Aquest controlador s\u2019acostuma a anomenar tamb\u00e9 pont JDBC-ODBC ( bridge en angl\u00e8s). Utilitzant aquest driver podrem enlla\u00e7ar qualsevol aplicaci\u00f3 Java amb qualsevol connexi\u00f3 ODBC. Actualment, la gran majoria d\u2019SGBD disposen de drivers JDBC, per\u00f2 en cas d\u2019haver de treballar amb un sistema que no en tinga, si disposa de controlador ODBC, podrem fer servir el pont JDBC-ODBC per aconseguir la connexi\u00f3 des de Java. Arquitectura JDBC \u00b6 La biblioteca est\u00e0ndard JDBC cont\u00e9 un gran nombre d\u2019interf\u00edcies sense les classes que les implementen. Els controladors o drivers dels SGBD concrets (i que els proporciona el fabricant del SGBD) s\u00f3n els que han d'implementar les interf\u00edcies anteriors i aix\u00ed accedir a les seues dades amb les particularitats que puga tenir el SGBD en concret. Des de les aplicacions s'utilitzaran les interf\u00edcies de JDBC, i d\u2019aquesta manera, el controlador utilitzat ser\u00e0 totalment transparent a l\u2019aplicaci\u00f3. D\u2019aquesta manera s\u2019aconsegueix independitzar l\u2019aplicaci\u00f3 dels controladors permetent la substituci\u00f3 del controlador original per qualsevol altre compatible JDBC sense pr\u00e0cticament necessitat d\u2019haver de modificar el codi de l\u2019aplicaci\u00f3. D'una banda trobem les interf\u00edcies definides a l'est\u00e0ndard (les figures amb fons transparent). Es tracta de l'API amb el que l'aplicaci\u00f3 treballar\u00e0 de forma directa. De l'altra banda trobem les classes espec\u00edfiques del controlador (driver) que interaccionen amb el SGBD i que implementen les interf\u00edcies de l'est\u00e0ndard JDBC. S\u00f3n les figures amb fons de diferents colors \u00c9s important destacar que JDBC no exigeix cap instal\u00b7laci\u00f3, ni cap canvi substancial en el codi a l\u2019hora de fer servir un o altre controlador. I fins i tot podrem utilitzar m\u00e9s d'un controlador per a poder connectar des de la mateixa aplicaci\u00f3 a m\u00e9s d'un SGBD. Aix\u00f2 \u00e9s possible perqu\u00e8: Java permet carregar en mem\u00f2ria qualsevol classe a partir del seu nom, i aix\u00ed carregar el o els controladors que necessitem. Es fa amb la sent\u00e8ncia Class.forName (\u201cnom_de_la_Classe\u201d). La classe DriverManager (de l\u2019API JDBC) \u00e9s capa\u00e7 de seleccionar el driver adequat d'entre tots els que estiguen carregats en mem\u00f2ria, sense necessitat d\u2019indicar-li el driver espec\u00edfic que cal fer servir. Tipus de controladors \u00b6 JDBC distingeix quatre tipus de controladors: 1. Tipus I . Controladors pont ( bridge driver ) com JDBC-ODBC. Es caracteritzen per fer servir una tecnologia externa a JDBC i actuar d\u2019adaptador entre les especificacions de l\u2019API JDBC i la tecnologia concreta utilitzada. El m\u00e9s conegut \u00e9s el controlador pont JDBC-ODBC , per\u00f2 n\u2019hi ha d\u2019altres, com JDBC-OLE DB. La seua principal ra\u00f3 de ser \u00e9s la de permetre utilitzar l'altra tecnologia (ODBC) que est\u00e0 molt estesa i assegurar aix\u00ed la connexi\u00f3 amb pr\u00e0cticament qualsevol font de dades. Cada client: Haur\u00e0 de tenir instal\u00b7lada una utilitat de gesti\u00f3 i configuraci\u00f3 de fonts de dades ODBC (o de la tecnologia utilitzada) Haur\u00e0 de tenir instal\u00b7lat el driver ODBC espec\u00edfic del\u2019SGBD al qual es vol accedir A trav\u00e9s de la primera utilitat crear un DSN (Data Source Name) que utilitze el driver del SGBD amb les dades de connexi\u00f3 al SGBD Com que la connexi\u00f3 \u00e9s a trav\u00e9s de ODBC (no directament) pot donar problemes de rendiment i, per tant, s\u2019aconsella fer servir aquest tipus de controlador nom\u00e9s com a \u00faltima alternativa. 2. Tipus II . Controladors de Java amb API parcialment nadiu ( Native- API partly Java driver ). S\u2019anomenen tamb\u00e9 simplement nadius . Com el seu nom indica, estan formats d\u2019una part codificada en Java i una altra part que usa biblioteques bin\u00e0ries instal\u00b7lades en el sistema operatiu. Aquest tipus de controladors existeixen perqu\u00e8 alguns Sistemes Gestors de Bases de Dades tenen entre les seues utilitats de s\u00e8rie connectors propis. Solen ser connectors propietaris que no segueixen cap est\u00e0ndard, ja que acostumen a ser anteriors a ODBC o JDBC, per\u00f2 es mantenen perqu\u00e8 solen estar molt optimitzats i s\u00f3n molt eficients. Utilitzant una tecnologia Java anomenada JNI \u00e9s possible implementar classes, els m\u00e8todes de les quals invoquen funcions de biblioteques bin\u00e0ries instal\u00b7lades en el sistema operatiu. Els controladors de tipus II utilitzen aquesta tecnologia per crear les classes implementadores de l\u2019API JDBC. En alguns casos pot requerir una instal\u00b7laci\u00f3 extra de certes utilitats a la part client, exigides pel connector nadiu del sistema gestor. 3. Tipus III . Controladors de Java via protocol de xarxa . Es tracta d\u2019un controlador escrit totalment en Java que tradueix les cridades JDBC a un protocol de xarxa contra un servidor intermedi (anomenat normalment Middleware ) que pot estar connectat a diversos SGBD. Aquest tipus de driver presenta l\u2019avantatge que utilitza un protocol independent dels SGBD i, per tant, el canvi de font de dades es pot fer de manera totalment transparent als clients. Aix\u00f2 el converteix en un sistema molt flexible, encara que per contra, es necessitar\u00e0 instal\u00b7lar, en algun lloc accessible de la xarxa, un servidor intermedi connectat a tots els SGBD que calga. Aquest tipus de controladors s\u00f3n molt \u00fatils quan hi ha un n\u00famero molt gran de clients, ja que els canvis d\u2019SGBD no requeriran cap canvi en els clients, ni tan sols la incorporaci\u00f3 d\u2019una nova biblioteca. 4 Tipus IV . Controladors de tipus Java pur o Java 100% . S\u2019anomenen tamb\u00e9 controladors de protocol nadiu . S\u00f3n controladors escrits totalment en Java. Les peticions al Sistema Gestor de Bases de Dades es fan sempre a trav\u00e9s del protocol de xarxa que utilitza el propi SGBD i, per tant, no es necessita ni codi nadiu en el client (com en el cas del tipus II) ni servidor intermedi (com en el cas del tipus III) per connectar amb la font de dades. Es tracta, doncs, d\u2019un driver que no requereix cap tipus d\u2019instal\u00b7laci\u00f3 ni requeriment, la qual cosa el fa ser una alternativa molt ben considerada que en els \u00faltims temps ha acabat imposant-se. De fet, la major part de fabricants ha acabat creant un controlador de tipus IV, tot i que segueixen mantenint tamb\u00e9 els dels altres tipus. Els tipus desitjables s\u00f3n el tipus III i sobretot el tipus IV , ja que d'aquesta manera no ens fa falta instal\u00b7lar res per a poder connectar. En aquest tema intentarem connectar a 3 Sistemes Gestors de Bases de Dades diferents: PostgreSQL , MySQL i SQLite Els drivers o controladors (tots de tiups IV) us els podeu baixar sense problemes. S\u00f3n f\u00e0cils de trobar, \u00fanicament amb un buscador posar jdbc i el Sistema Gestor de Bases de Dades (per exemple jdbc postgresql ). De tota manera, per m\u00e9s comoditat, teniu una carpeta en el curs de Aules amb tots els drivers que ens fan falta. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement CompartirIgual 2.5","title":"3 - Connexi\u00f3 a les B. Connectors"},{"location":"3__connexi_a_les_bd_connectors/#3-connexio-a-les-bd-connectors","text":"Deixem de banda de moment el desfasament Objecte-Relacional i centrem-nos ara en l'acc\u00e9s a Base de Dades Relacionals des dels llenguatges de programaci\u00f3. Ho raonarem en general i ho aplicarem a Java-Kotlin. Des de la d\u00e8cada dels 80 que existeixen a ple rendiment les Bases de Dades Relacionals. Quasi tots els Sistemes Gestors de Bases de Dades (excepte els m\u00e9s xicotets com Access, Base de LibreOffice o SQLite) utilitzen l'arquitectura client-servidor. Aix\u00f2 vol dir que hi ha un ordinador central on est\u00e0 instal\u00b7lat el Sistema Gestor de Bases de Dades Relacional que actua com a servidor, i hi haur\u00e0 molts clients que es connectaran al servidor fent peticions sobre la Base de Dades. Els Sistemes Gestors de Bases de Dades inicialment disposaven de llenguatges de programaci\u00f3 propis per a poder fer els accesos des dels clients. Era molt consistent, per\u00f2 a base de ser molt poc operatiu: L'empresa desenvolupadora del SGBD havia de mantenir un llenguatge de programaci\u00f3, que resultava necess\u00e0riament molt cost\u00f3s, si no volien que quedara desfasat. Les empreses usu\u00e0ries del SGBD, que es connectaven com a clients, es trobaven molt lligades al servidor per haver d'utilitzar el llenguatge de programaci\u00f3 per accedir al servidor, cosa que no sempre s'ajustava a les seues necessitats. A m\u00e9s, el plantejar-se canviar de servidor, volia dir que s'havien de re-fer tots els programes, i per tant una tasca de molt\u00edssima envergadura. Per a poder ser m\u00e9s operatius, calia desvincular els llenguatges de programaci\u00f3 dels Sistemes Gestors de Bases de Dades utilitzant uns est\u00e0ndars de connexi\u00f3.","title":"3 - Connexi\u00f3 a les BD: Connectors"},{"location":"3__connexi_a_les_bd_connectors/#31-odbc","text":"A mida que les teories de dades relacionals anaven agafant for\u00e7a i les xarxes guanyaven adeptes gr\u00e0cies a l\u2019increment de l\u2019efici\u00e8ncia a preus realment competitius, van comen\u00e7ar a implementar-se uns Sistemes Gestors de Bases de Dades basats en la tecnologia client-servidor, que van triomfar. La tecnologia client-servidor va permetre a\u00efllar les dades i els programes espec\u00edfics d\u2019acc\u00e9s a aquestes dades, del desenvolupament de l\u2019aplicaci\u00f3. La ra\u00f3 principal d\u2019aquesta divisi\u00f3 va ser segurament possibilitar l\u2019acc\u00e9s remot a les dades de qualsevol ordinador connectat a la xarxa. El cert, per\u00f2, \u00e9s que aquest fet va emp\u00e8nyer els Sistemes de Bases de Dades a desenvolupar-se d\u2019una forma a\u00efllada i a crear protocols i llenguatges espec\u00edfics per poder-se comunicar remotament amb les aplicacions que corrien en els clients. Per dir- lo d'alguna manera, havien de desenvolupar els servidors i tamb\u00e9 els clients, per a poder connectar-se amb el servidor. A poc a poc, el software al voltant de les bases de dades va cr\u00e9ixer espectacularment intentant donar resposta a un m\u00e0xim de demandes a trav\u00e9s de sistemes altament configurables. \u00c9s el que avui dia es coneix com a middleware o capa interm\u00e8dia de persist\u00e8ncia. \u00c9s a dir, el conjunt d\u2019aplicacions, utilitats, biblioteques, protocols i llenguatges, situats tant a la part servidor com a la part client, que permeten connectar-se remotament a una base de dades per configurar-la o explotar-ne les seues dades. L'arribada dels est\u00e0ndards Inicialment, cada empresa desenvolupadora d\u2019un SGBD implementava les seues solucions espec\u00edfiques per al seu sistema, per\u00f2 prompte es van donar compte que col\u00b7laborant conjuntament podien treure\u2019n major rendiment i avan\u00e7ar molt m\u00e9s r\u00e0pidament. Sostenint-se en el Model Relacional i en algunes implementacions primerenques de les empreses IBM i Oracle, es va desenvolupar el llenguatge de consulta de dades anomenat SQL ( Structured Query Language ). Va ser un gran pas endavant, perqu\u00e8 s'uniformava la manera d'accedir a la BD, per\u00f2 les aplicacions necessitaven API amb funcions que permeteren fer crides des del llenguatge de desenvolupament per enviar les consultes SQL. Cada SGBD t\u00e9 la seua pr\u00f2pia connexi\u00f3 i el seu propi API. El grup anomenat SQL Access Group , en el qual participaven prestigioses empreses del sector com Oracle, Informix, Ingres, DEC, Sun o HP, va definir un API universal amb independ\u00e8ncia del llenguatge de desenvolupament i la Base de Dades a connectar. El 1992, Microsoft i Simba implementen l\u2019 ODBC ( Open Data Base Connectivity ), un API basat en la definici\u00f3 del SQL Acces Group , que s\u2019integra en el sistema operatiu de Windows i que permet afegir m\u00faltiples connectors (o controladors o Drivers ) a diverses Bases de Dades Relacionals (que utilitzen SQL) de forma molt senzilla i transparent, ja que els connectors s\u00f3n autoinstal\u00b7lables i totalment configurables des de les mateixes eines del Sistema Operatiu. D'aquesta manera, tenint instal\u00b7lat ODBC (i en Windows acabar\u00e0 venint instal\u00b7lat per defecte), les aplicacions es connectaran a trav\u00e9s d'ODBC a qualsevol dels SGBD del qual tinguem instal\u00b7lat el connector. Per a connectar a una Base de Dades o una altra, nom\u00e9s hem de canviar de controlador, sense haver de canviar la pr\u00f2pia aplicaci\u00f3. L\u2019arribada de l\u2019ODBC va representar un pas sense precedents en el cam\u00ed cap a la interoperabilitat entre bases de dades i llenguatges de programaci\u00f3. La majoria d\u2019empreses desenvolupadores de Sistemes Gestors de Bases de Dades van proporcionar els drivers de connectivitat, i els llenguatges de programaci\u00f3 m\u00e9s importants van desenvolupar biblioteques espec\u00edfiques per suportar l\u2019API ODBC. La situaci\u00f3 actual Actualment, ODBC continua sent una adequada manera de connectar als SGDB Relacionals. El seu desenvolupament segueix liderat per Microsoft, per\u00f2 existeixen versions per a altres Sistemes Operatius com UNIX/LINUX o MAC. Els llenguatges m\u00e9s populars de desenvolupament mantenen actualitzades les biblioteques de comunicaci\u00f3 amb les successives versions que han anat apareixent i la majoria de SGBD disposen d\u2019un controlador ODBC b\u00e0sic. I per tant la connexi\u00f3 queda garantida. Actualment, l\u2019ODBC s\u2019estructura en tres nivells. El primer, anomenat core API , \u00e9s el nivell m\u00e9s b\u00e0sic corresponent a l\u2019especificaci\u00f3 original (basada en el SQL Access Group ). El Level 1 API i el Level 2 API afegeixen funcionalitats avan\u00e7ades, com cridades a procediments guardats en el Sistema Gestor de Bases de Dades, aspectes de seguretat d\u2019acc\u00e9s, definici\u00f3 de tipus estructurats, etc. En realitat, l\u2019ODBC \u00e9s una especificaci\u00f3 de baix nivell, \u00e9s a dir, de funcions b\u00e0siques que possibiliten la connexi\u00f3, que asseguren l\u2019atomicitat de les peticions, el retorn d\u2019informaci\u00f3, el capsulament del llenguatge de consulta SQL o l\u2019obtenci\u00f3 de dades aconseguides en resposta a un petici\u00f3. La funcionalitat de baix nivell fa que es puga adaptar a moltes aplicacions; aix\u00f2 s\u00ed, a costa d\u2019un considerable nombre de l\u00ednies de codi necess\u00e0ries per adaptar-se a la l\u00f2gica de cada aplicaci\u00f3. \u00c9s per aix\u00f2 que sobre la base de l\u2019ODBC han sorgit altres alternatives de persist\u00e8ncia de m\u00e9s alt nivell. Per exemple, Microsoft ha desenvolupat OLE DB o ADO.NET. Aquest \u00faltim possibilita ja els objectes per a qualsevol tipus d\u2019aplicaci\u00f3 basada en la plataforma .NET.","title":"3.1 - ODBC"},{"location":"3__connexi_a_les_bd_connectors/#32-jdbc","text":"Pr\u00e0cticament de forma simult\u00e0nia a ODBC, l\u2019empresa Sun Microsystems, l\u2019any 1997 va treure a la llum JDBC ( Java DataBase Connectivity ), un API connector de bases de dades, implementat espec\u00edficament per a utilitzar amb el llenguatge Java. Es tracta d\u2019un API molt similar a ODBC quant a la manera de funcionar: Tindrem l'API JDBC que utilitzaran les aplicacions que vulguen connectar a les Bases de Dades, i que garatitza una uniformitat, siga quina siga la o les Bases de Dades a connectar Ens far\u00e0 falta un controlador o driver per cada Base de Dades a la qual vulguem connectar Per\u00f2 com coment\u00e0vem, est\u00e0 adaptat espec\u00edficament per a Java. \u00c9s a dir, la funcionalitat es troba encapsulada en classes (ja que Java \u00e9s un llenguatge totalment orientat a objectes) i a m\u00e9s, no dep\u00e8n de cap plataforma especifica, d\u2019acord amb la caracter\u00edstica multiplataforma defensada per Java. Aquest connector ser\u00e0 l\u2019API que estudiarem en detall en aquesta unitat, ja que Java no disposa de cap biblioteca espec\u00edfica ODBC. Les raons esgrimides per Sun s\u00f3n que ODBC no es pot fer servir directament en Java ja que est\u00e0 implementat en C i no \u00e9s orientat a objectes. Per\u00f2, per a no perdre la potencialitat de les connexions ODBC, que recordem que ens permetia connectar a qualsevol Base de Dades Relacional, Sun Microsystem ha optat per incorporar de s\u00e8rie un driver especial que actua d\u2019adaptador entre l\u2019especificaci\u00f3 JDBC i l\u2019especificaci\u00f3 ODBC. Aquest controlador s\u2019acostuma a anomenar tamb\u00e9 pont JDBC-ODBC ( bridge en angl\u00e8s). Utilitzant aquest driver podrem enlla\u00e7ar qualsevol aplicaci\u00f3 Java amb qualsevol connexi\u00f3 ODBC. Actualment, la gran majoria d\u2019SGBD disposen de drivers JDBC, per\u00f2 en cas d\u2019haver de treballar amb un sistema que no en tinga, si disposa de controlador ODBC, podrem fer servir el pont JDBC-ODBC per aconseguir la connexi\u00f3 des de Java.","title":"3.2 - JDBC"},{"location":"3__connexi_a_les_bd_connectors/#arquitectura-jdbc","text":"La biblioteca est\u00e0ndard JDBC cont\u00e9 un gran nombre d\u2019interf\u00edcies sense les classes que les implementen. Els controladors o drivers dels SGBD concrets (i que els proporciona el fabricant del SGBD) s\u00f3n els que han d'implementar les interf\u00edcies anteriors i aix\u00ed accedir a les seues dades amb les particularitats que puga tenir el SGBD en concret. Des de les aplicacions s'utilitzaran les interf\u00edcies de JDBC, i d\u2019aquesta manera, el controlador utilitzat ser\u00e0 totalment transparent a l\u2019aplicaci\u00f3. D\u2019aquesta manera s\u2019aconsegueix independitzar l\u2019aplicaci\u00f3 dels controladors permetent la substituci\u00f3 del controlador original per qualsevol altre compatible JDBC sense pr\u00e0cticament necessitat d\u2019haver de modificar el codi de l\u2019aplicaci\u00f3. D'una banda trobem les interf\u00edcies definides a l'est\u00e0ndard (les figures amb fons transparent). Es tracta de l'API amb el que l'aplicaci\u00f3 treballar\u00e0 de forma directa. De l'altra banda trobem les classes espec\u00edfiques del controlador (driver) que interaccionen amb el SGBD i que implementen les interf\u00edcies de l'est\u00e0ndard JDBC. S\u00f3n les figures amb fons de diferents colors \u00c9s important destacar que JDBC no exigeix cap instal\u00b7laci\u00f3, ni cap canvi substancial en el codi a l\u2019hora de fer servir un o altre controlador. I fins i tot podrem utilitzar m\u00e9s d'un controlador per a poder connectar des de la mateixa aplicaci\u00f3 a m\u00e9s d'un SGBD. Aix\u00f2 \u00e9s possible perqu\u00e8: Java permet carregar en mem\u00f2ria qualsevol classe a partir del seu nom, i aix\u00ed carregar el o els controladors que necessitem. Es fa amb la sent\u00e8ncia Class.forName (\u201cnom_de_la_Classe\u201d). La classe DriverManager (de l\u2019API JDBC) \u00e9s capa\u00e7 de seleccionar el driver adequat d'entre tots els que estiguen carregats en mem\u00f2ria, sense necessitat d\u2019indicar-li el driver espec\u00edfic que cal fer servir.","title":"Arquitectura JDBC"},{"location":"3__connexi_a_les_bd_connectors/#tipus-de-controladors","text":"JDBC distingeix quatre tipus de controladors: 1. Tipus I . Controladors pont ( bridge driver ) com JDBC-ODBC. Es caracteritzen per fer servir una tecnologia externa a JDBC i actuar d\u2019adaptador entre les especificacions de l\u2019API JDBC i la tecnologia concreta utilitzada. El m\u00e9s conegut \u00e9s el controlador pont JDBC-ODBC , per\u00f2 n\u2019hi ha d\u2019altres, com JDBC-OLE DB. La seua principal ra\u00f3 de ser \u00e9s la de permetre utilitzar l'altra tecnologia (ODBC) que est\u00e0 molt estesa i assegurar aix\u00ed la connexi\u00f3 amb pr\u00e0cticament qualsevol font de dades. Cada client: Haur\u00e0 de tenir instal\u00b7lada una utilitat de gesti\u00f3 i configuraci\u00f3 de fonts de dades ODBC (o de la tecnologia utilitzada) Haur\u00e0 de tenir instal\u00b7lat el driver ODBC espec\u00edfic del\u2019SGBD al qual es vol accedir A trav\u00e9s de la primera utilitat crear un DSN (Data Source Name) que utilitze el driver del SGBD amb les dades de connexi\u00f3 al SGBD Com que la connexi\u00f3 \u00e9s a trav\u00e9s de ODBC (no directament) pot donar problemes de rendiment i, per tant, s\u2019aconsella fer servir aquest tipus de controlador nom\u00e9s com a \u00faltima alternativa. 2. Tipus II . Controladors de Java amb API parcialment nadiu ( Native- API partly Java driver ). S\u2019anomenen tamb\u00e9 simplement nadius . Com el seu nom indica, estan formats d\u2019una part codificada en Java i una altra part que usa biblioteques bin\u00e0ries instal\u00b7lades en el sistema operatiu. Aquest tipus de controladors existeixen perqu\u00e8 alguns Sistemes Gestors de Bases de Dades tenen entre les seues utilitats de s\u00e8rie connectors propis. Solen ser connectors propietaris que no segueixen cap est\u00e0ndard, ja que acostumen a ser anteriors a ODBC o JDBC, per\u00f2 es mantenen perqu\u00e8 solen estar molt optimitzats i s\u00f3n molt eficients. Utilitzant una tecnologia Java anomenada JNI \u00e9s possible implementar classes, els m\u00e8todes de les quals invoquen funcions de biblioteques bin\u00e0ries instal\u00b7lades en el sistema operatiu. Els controladors de tipus II utilitzen aquesta tecnologia per crear les classes implementadores de l\u2019API JDBC. En alguns casos pot requerir una instal\u00b7laci\u00f3 extra de certes utilitats a la part client, exigides pel connector nadiu del sistema gestor. 3. Tipus III . Controladors de Java via protocol de xarxa . Es tracta d\u2019un controlador escrit totalment en Java que tradueix les cridades JDBC a un protocol de xarxa contra un servidor intermedi (anomenat normalment Middleware ) que pot estar connectat a diversos SGBD. Aquest tipus de driver presenta l\u2019avantatge que utilitza un protocol independent dels SGBD i, per tant, el canvi de font de dades es pot fer de manera totalment transparent als clients. Aix\u00f2 el converteix en un sistema molt flexible, encara que per contra, es necessitar\u00e0 instal\u00b7lar, en algun lloc accessible de la xarxa, un servidor intermedi connectat a tots els SGBD que calga. Aquest tipus de controladors s\u00f3n molt \u00fatils quan hi ha un n\u00famero molt gran de clients, ja que els canvis d\u2019SGBD no requeriran cap canvi en els clients, ni tan sols la incorporaci\u00f3 d\u2019una nova biblioteca. 4 Tipus IV . Controladors de tipus Java pur o Java 100% . S\u2019anomenen tamb\u00e9 controladors de protocol nadiu . S\u00f3n controladors escrits totalment en Java. Les peticions al Sistema Gestor de Bases de Dades es fan sempre a trav\u00e9s del protocol de xarxa que utilitza el propi SGBD i, per tant, no es necessita ni codi nadiu en el client (com en el cas del tipus II) ni servidor intermedi (com en el cas del tipus III) per connectar amb la font de dades. Es tracta, doncs, d\u2019un driver que no requereix cap tipus d\u2019instal\u00b7laci\u00f3 ni requeriment, la qual cosa el fa ser una alternativa molt ben considerada que en els \u00faltims temps ha acabat imposant-se. De fet, la major part de fabricants ha acabat creant un controlador de tipus IV, tot i que segueixen mantenint tamb\u00e9 els dels altres tipus. Els tipus desitjables s\u00f3n el tipus III i sobretot el tipus IV , ja que d'aquesta manera no ens fa falta instal\u00b7lar res per a poder connectar. En aquest tema intentarem connectar a 3 Sistemes Gestors de Bases de Dades diferents: PostgreSQL , MySQL i SQLite Els drivers o controladors (tots de tiups IV) us els podeu baixar sense problemes. S\u00f3n f\u00e0cils de trobar, \u00fanicament amb un buscador posar jdbc i el Sistema Gestor de Bases de Dades (per exemple jdbc postgresql ). De tota manera, per m\u00e9s comoditat, teniu una carpeta en el curs de Aules amb tots els drivers que ens fan falta. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement CompartirIgual 2.5","title":"Tipus de controladors"},{"location":"4__tocar_les_dades/","text":"4 - \"Tocar\" les dades \u00b6 Abans de comen\u00e7ar a treballar la persist\u00e8ncia en diferents Bases de Dades Relacionals, ens convindr\u00e0 accedir al Sistema Gestor de Base de Dades per a poder veure les dades, treballar amb elles. B\u00e0sicament voldrem: Poder veure les taules de la Base de Dades Poder veure l'estructura de cada taula: camps, tipus dels camps, clau principal, ... Poder veure les dades d'una taula, fins i tot poder indroduir noves files, esborrar o modificar de forma c\u00f2moda Poder editar i executar sent\u00e8ncies SQL de forma c\u00f2moda L'entorn d'IntelliJ ens proporciona una eina ja instal\u00b7lada, Database , a la qual es pot accedir des de View - > Tool windows -> Database . \u00c9s una bona manera de poder connectar i \"tocar\" les dades sense tenir un client espec\u00edfic del Sistema Gestor de Base de Dades al qual volem accedir. Per\u00f2 est\u00e0 clar que si disposem d'un client espec\u00edfic del SGBD, ser\u00e0 m\u00e9s c\u00f2mode que amb la perspectiva anterior. Per aix\u00f2 veurem una eina que ens permet connectar a quasi tots els Sistemes Gestors de Bases de Dades Relacionals, i per tant amb una \u00fanica eina podem connectar on vulguem. \u00c9s el DBeaver . 4.1 - Des de IntelliJ \u00b6 Des dels programes Java o Kotlin podr\u00edem connectar ja mateix a les diferents BD amb els connectors JDBC, per\u00f2 abans ens faria falta poder veure les taules amb les dades i fins i tot administrar aquestes Bases de Dades. Aix\u00f2 es pot fer des d'IntelliJ sense molt f\u00e0cilment, ja que en la nostra versi\u00f3 ho tenim integrat per defecte. Utilitzarem els connectors (drivers) JDBC, per a connectar a les Bases de Dades, per\u00f2 d'una forma independent dels projectes. La manera d'accedir \u00e9s: Wiew -- > Tool Windows --> Database i se'ns obrir\u00e0 una subfinestra a la dreta per a poder \"treballar\" amb les Bases de Dades Des d'aquesta finestra podrem controlar les connexions a Bases de Dades i tamb\u00e9 els Drivers JDBC que ens permeten connectar. Com hem comentat ser\u00e0 independent dels projectes Java o Kotlin Connexi\u00f3 a PostgreSQL Com a primer exemple de connexi\u00f3, intentarem connectar a PostgreSQL. Far\u00e0 falta especificar: Les dades de connexi\u00f3, que seran: Servidor (host): 89.36.214.106 Port: 5432 (\u00e9s el port per defecte) Usuari: geo_ad Contrasenya: geo_ad Base de dades: geo_ad En el moment que demana pel controlador (driver) de PostgreSQL, apretar a baixar. Ser\u00e0 un de tipus IV. A\u00e7\u00f2 nom\u00e9s ser\u00e0 necessari la primera vegada que connectem a PostgreSQL. De la configuraci\u00f3 anterior podem observar la URL de connexi\u00f3 que va a continuaci\u00f3. \u00c9s important, perqu\u00e8 despr\u00e9s quan connectem des dels nostres programes Java, haurem d'especificar-la tamb\u00e9. Haurem de substituir servidor per l'adre\u00e7a IP o el nom del servidor, la base_de_dades per la base de dades a la qual ens volem connectar. URL de PostgreSQL jdbc:postgresql://_servidor_ :5432/_base_de_dades que en el nostre exemple ha quedat: jdbc:postgresql://89.36.214.106:5432/geo_ad Connexi\u00f3 a MySQL Repetim el proc\u00e9s per a MySQL. El servidor est\u00e0 en la mateixa m\u00e0quina que PostgreSQL (89.36.214.106). L'usuari amb que connectarem ara es diu factura . Haurem d'especificar: Les dades de connexi\u00f3, que seran: Servidor: 89.36.214.106 Port: 3306 Usuari: factura Contrasenya: factura Base de dades: factura Quan demane pel controlador (driver) de MySQL, haurem d'apretar a baixar. A\u00e7\u00f2 nom\u00e9s ser\u00e0 necessari la primera vegada que connectem a MySQL URL de MySQL jdbc:mysql://_servidor_ :3306/_base_de_dades que en el nostre exemple queda: jdbc:mysql://89.36.214.106:3306/factura Connexi\u00f3 a SQLite SQLite \u00e9s un SGBD molt diferent als anteriors. En tots els anteriors s'utilitza l'arquitectura client-servidor. I per tant el servidor de Base de Dades no t\u00e9 per qu\u00e8 estar en la mateixa m\u00e0quina. Per\u00f2 en moltes ocasions ens pot venir b\u00e9 un SGBD molt m\u00e9s xicotet i senzill que guarde la BD en la mateixa m\u00e0quina, que siga monousuari i que pese molt poc. SQLite \u00e9s un SGBD multiplataforma (podrem fer-lo rodar en qualsevol plataforma) que \u00e9s molt lleuger. Admet la major part de l'est\u00e0ndar SQL-92. I guarda una Base de Dades en un \u00fanic fitxer. Una altra caracter\u00edstica \u00e9s que des de Java o Kotlin, amb el driver JDBC podrem accedir a les Bases de Dades SQLite sense que fa\u00e7a falta cap motor de Base de Dades. Per tant \u00e9s ideal com a Base de Dades que puguem copiar a les nostres aplicacions. Quan connectem des de IntelliJ ara no caldr\u00e0 especificar on est\u00e0 el servidor ni quin usuari s'ha de connectar. Haurem de dir el fitxer amb la ruta on est\u00e0 (o estar\u00e0) la Base de Dades. Per tant nom\u00e9s haurem d'especificar: Les dades del fitxer: ruta i nom. La ruta ha d'existir. Si el fitxer no existeix, el crear\u00e0. Quan ens diga baixarem el Driver. Aix\u00f2 nom\u00e9s ens caldr\u00e0 la primera vegada que connectem amb SQLite URL de SQLite jdbc:sqlite:ruta_del_fitxer_sqlite Com hem comentat, SQLite \u00e9s m\u00e9s senzill que els altres SGBD. Concretament, els tipus de dades que utilitza s\u00f3n: INTEGER . El valor \u00e9s un enter amb signe, que ocupa 1, 2, 3, 4, 6, o 8 bytes depenent de la grand\u00e0ria del valor. REAL . El valor \u00e9s un n\u00famero real en coma flotant que ocupa 8 bytes (doble precisi\u00f3). TEXT . El valor \u00e9s una cadena de car\u00e0cters que pot estar codificada en UTF-8, UTF-16BE o UTF-16LE, depenent de la codificaci\u00f3 de la Base de Dades. No ens preocuparem de la codificaci\u00f3 interna. BLOB . Per a guardar dades bin\u00e0ries que es guardaran exactament com entren, sense mirar el format. Des de l'entorn d'IntelliJ podrem visualitzar les taules i fins i tot crear- les, amb SQL. 4.2 - DBeaver \u00b6 Ja hem vist la utilitat d'inspeccionar les Bases de Dades que ens proporciona IntelliJ, i que ens permet accedir a les Bases de Dades per veure l'estructura i les dades de les taules, fins i tot, fer i executar sent\u00e8ncies SQl. Per\u00f2 no \u00e9s excessivament c\u00f2moda. Els Sistemes Gestors de Bases de Dades tenen clients espec\u00edfics per a poder treballar amb les seues Bases de Dades. Per\u00f2 hi ha un altre software, lliure, anomenat DBeaver que ens permet connectar a quasi totes les Bases de Dades Relacionals, i fins i tot a moltes BD NoSQL en la seua versi\u00f3 comercial (Enterprise Edition). Nosaltres utilitzarem la que s\u00ed que \u00e9s de codi obert, la Community Edition. Ens ho podem baixar des de la seua p\u00e0gina de desc\u00e0rregues, https://dbeaver.io/download . En el moment de fer aquestos apunts van per la versi\u00f3 24.2.2 La seua instal\u00b7laci\u00f3 no ofereix cap dificultat. En concret, per a Ubuntu, ens ofereix un paquet Debian, que senzillament hem d'instal\u00b7lar com a superusuari. Aquest \u00e9s el seu aspecte: Anem a crear una connexi\u00f3 a PostgeSQL, una altra a MySQL i una altra a SQLite. Quan creem una nova connexi\u00f3 ja podem veure que es pot fer a molts SGBD. En la primera pantalla ja tenim els 3 que volem nosaltres, per\u00f2 hi ha molts m\u00e9s Quan li fa\u00e7a falta un Driver (que per cert seran drivers JDBC) ens preguntar\u00e0 de baixar-lo autom\u00e0ticament, per tant ser\u00e0 comod\u00edssim. PostgreSQL Aquestes s\u00f3n les dades de connexi\u00f3 que farem: Nom de la connexi\u00f3: el que vulguem, per exemple geo_ad Host: 89.36.214.106 Port: 5432 (\u00e9s el port per defecte) Database: geo_ad Usuari: geo_ad Contrasenya: geo_ad I en la pestanya PostgreSQL cuidem de no tenir seleccionada l'opci\u00f3 Show all databases , ja que \u00e9s in\u00fatil mostrar Bases de Dades a les quals no tindrem acc\u00e9s Una vegada creada la connexi\u00f3 podrem navegar fins les taules, i en seleccionar una veurem en 3 pestanyes l'estructura, les dades, i fins i tot un esquema de l'estil del Model Entitat-Relaci\u00f3 (encara que en realitat representa el Model Relacional) on interv\u00e9 la taula, \u00e9s a dir, ens mostra les seues claus externes. Finalment observem com tamb\u00e9 podem executar sent\u00e8ncies SQL de forma molt c\u00f2mode, i on ens d\u00f3na molta ajuda per escriure correctament les paraules reservades i tamb\u00e9 les taules i camps de la nostra BD MySQL Nom de la connexi\u00f3: el que vulgueu, per exemple Connexio MySQL factura Servidor: 89.36.214.106 Port: 3306 Base de dades: factura Usuari: factura Contrasenya: factura La seua utilitzaci\u00f3 \u00e9s igual de f\u00e0cil que en l'anterior cas. SQLite La connexi\u00f3 a SQLite \u00e9s m\u00e9s senzilla i per tant ens preguntar\u00e0 menys coses: Nom de la connexi\u00f3 Ruta i nom del fitxer L'entorn ser\u00e0 totalment similar als dels casos anteriors. Per\u00f2 en aquesta Base de Dades de prova, proveta.sqlite no ten\u00edem cap taula: Aprofitem per a crear una taula, per veure que \u00e9s molt f\u00e0cil i c\u00f2mode. Crearem una taula T1 amb 2 camps, c1 num\u00e8ric, i c2 de text. Potser el menys intu\u00eftiu \u00e9s la manera de crear els camps de la taula. Ser\u00e0 apretant amb el bot\u00f3 de la dreta en la zona de les columnes. En les seg\u00fcents imatges es veu com es creen 2 camps. La tercera \u00e9s en el moment de guardar la taula, i podem comprovar que el que fa \u00e9s generar una consulta SQL Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement CompartirIgual 2.5","title":"4 - \"Tocar\" les dades"},{"location":"4__tocar_les_dades/#4-tocar-les-dades","text":"Abans de comen\u00e7ar a treballar la persist\u00e8ncia en diferents Bases de Dades Relacionals, ens convindr\u00e0 accedir al Sistema Gestor de Base de Dades per a poder veure les dades, treballar amb elles. B\u00e0sicament voldrem: Poder veure les taules de la Base de Dades Poder veure l'estructura de cada taula: camps, tipus dels camps, clau principal, ... Poder veure les dades d'una taula, fins i tot poder indroduir noves files, esborrar o modificar de forma c\u00f2moda Poder editar i executar sent\u00e8ncies SQL de forma c\u00f2moda L'entorn d'IntelliJ ens proporciona una eina ja instal\u00b7lada, Database , a la qual es pot accedir des de View - > Tool windows -> Database . \u00c9s una bona manera de poder connectar i \"tocar\" les dades sense tenir un client espec\u00edfic del Sistema Gestor de Base de Dades al qual volem accedir. Per\u00f2 est\u00e0 clar que si disposem d'un client espec\u00edfic del SGBD, ser\u00e0 m\u00e9s c\u00f2mode que amb la perspectiva anterior. Per aix\u00f2 veurem una eina que ens permet connectar a quasi tots els Sistemes Gestors de Bases de Dades Relacionals, i per tant amb una \u00fanica eina podem connectar on vulguem. \u00c9s el DBeaver .","title":"4 - \"Tocar\" les dades"},{"location":"4__tocar_les_dades/#41-des-de-intellij","text":"Des dels programes Java o Kotlin podr\u00edem connectar ja mateix a les diferents BD amb els connectors JDBC, per\u00f2 abans ens faria falta poder veure les taules amb les dades i fins i tot administrar aquestes Bases de Dades. Aix\u00f2 es pot fer des d'IntelliJ sense molt f\u00e0cilment, ja que en la nostra versi\u00f3 ho tenim integrat per defecte. Utilitzarem els connectors (drivers) JDBC, per a connectar a les Bases de Dades, per\u00f2 d'una forma independent dels projectes. La manera d'accedir \u00e9s: Wiew -- > Tool Windows --> Database i se'ns obrir\u00e0 una subfinestra a la dreta per a poder \"treballar\" amb les Bases de Dades Des d'aquesta finestra podrem controlar les connexions a Bases de Dades i tamb\u00e9 els Drivers JDBC que ens permeten connectar. Com hem comentat ser\u00e0 independent dels projectes Java o Kotlin Connexi\u00f3 a PostgreSQL Com a primer exemple de connexi\u00f3, intentarem connectar a PostgreSQL. Far\u00e0 falta especificar: Les dades de connexi\u00f3, que seran: Servidor (host): 89.36.214.106 Port: 5432 (\u00e9s el port per defecte) Usuari: geo_ad Contrasenya: geo_ad Base de dades: geo_ad En el moment que demana pel controlador (driver) de PostgreSQL, apretar a baixar. Ser\u00e0 un de tipus IV. A\u00e7\u00f2 nom\u00e9s ser\u00e0 necessari la primera vegada que connectem a PostgreSQL. De la configuraci\u00f3 anterior podem observar la URL de connexi\u00f3 que va a continuaci\u00f3. \u00c9s important, perqu\u00e8 despr\u00e9s quan connectem des dels nostres programes Java, haurem d'especificar-la tamb\u00e9. Haurem de substituir servidor per l'adre\u00e7a IP o el nom del servidor, la base_de_dades per la base de dades a la qual ens volem connectar. URL de PostgreSQL jdbc:postgresql://_servidor_ :5432/_base_de_dades que en el nostre exemple ha quedat: jdbc:postgresql://89.36.214.106:5432/geo_ad Connexi\u00f3 a MySQL Repetim el proc\u00e9s per a MySQL. El servidor est\u00e0 en la mateixa m\u00e0quina que PostgreSQL (89.36.214.106). L'usuari amb que connectarem ara es diu factura . Haurem d'especificar: Les dades de connexi\u00f3, que seran: Servidor: 89.36.214.106 Port: 3306 Usuari: factura Contrasenya: factura Base de dades: factura Quan demane pel controlador (driver) de MySQL, haurem d'apretar a baixar. A\u00e7\u00f2 nom\u00e9s ser\u00e0 necessari la primera vegada que connectem a MySQL URL de MySQL jdbc:mysql://_servidor_ :3306/_base_de_dades que en el nostre exemple queda: jdbc:mysql://89.36.214.106:3306/factura Connexi\u00f3 a SQLite SQLite \u00e9s un SGBD molt diferent als anteriors. En tots els anteriors s'utilitza l'arquitectura client-servidor. I per tant el servidor de Base de Dades no t\u00e9 per qu\u00e8 estar en la mateixa m\u00e0quina. Per\u00f2 en moltes ocasions ens pot venir b\u00e9 un SGBD molt m\u00e9s xicotet i senzill que guarde la BD en la mateixa m\u00e0quina, que siga monousuari i que pese molt poc. SQLite \u00e9s un SGBD multiplataforma (podrem fer-lo rodar en qualsevol plataforma) que \u00e9s molt lleuger. Admet la major part de l'est\u00e0ndar SQL-92. I guarda una Base de Dades en un \u00fanic fitxer. Una altra caracter\u00edstica \u00e9s que des de Java o Kotlin, amb el driver JDBC podrem accedir a les Bases de Dades SQLite sense que fa\u00e7a falta cap motor de Base de Dades. Per tant \u00e9s ideal com a Base de Dades que puguem copiar a les nostres aplicacions. Quan connectem des de IntelliJ ara no caldr\u00e0 especificar on est\u00e0 el servidor ni quin usuari s'ha de connectar. Haurem de dir el fitxer amb la ruta on est\u00e0 (o estar\u00e0) la Base de Dades. Per tant nom\u00e9s haurem d'especificar: Les dades del fitxer: ruta i nom. La ruta ha d'existir. Si el fitxer no existeix, el crear\u00e0. Quan ens diga baixarem el Driver. Aix\u00f2 nom\u00e9s ens caldr\u00e0 la primera vegada que connectem amb SQLite URL de SQLite jdbc:sqlite:ruta_del_fitxer_sqlite Com hem comentat, SQLite \u00e9s m\u00e9s senzill que els altres SGBD. Concretament, els tipus de dades que utilitza s\u00f3n: INTEGER . El valor \u00e9s un enter amb signe, que ocupa 1, 2, 3, 4, 6, o 8 bytes depenent de la grand\u00e0ria del valor. REAL . El valor \u00e9s un n\u00famero real en coma flotant que ocupa 8 bytes (doble precisi\u00f3). TEXT . El valor \u00e9s una cadena de car\u00e0cters que pot estar codificada en UTF-8, UTF-16BE o UTF-16LE, depenent de la codificaci\u00f3 de la Base de Dades. No ens preocuparem de la codificaci\u00f3 interna. BLOB . Per a guardar dades bin\u00e0ries que es guardaran exactament com entren, sense mirar el format. Des de l'entorn d'IntelliJ podrem visualitzar les taules i fins i tot crear- les, amb SQL.","title":"4.1 - Des de IntelliJ"},{"location":"4__tocar_les_dades/#42-dbeaver","text":"Ja hem vist la utilitat d'inspeccionar les Bases de Dades que ens proporciona IntelliJ, i que ens permet accedir a les Bases de Dades per veure l'estructura i les dades de les taules, fins i tot, fer i executar sent\u00e8ncies SQl. Per\u00f2 no \u00e9s excessivament c\u00f2moda. Els Sistemes Gestors de Bases de Dades tenen clients espec\u00edfics per a poder treballar amb les seues Bases de Dades. Per\u00f2 hi ha un altre software, lliure, anomenat DBeaver que ens permet connectar a quasi totes les Bases de Dades Relacionals, i fins i tot a moltes BD NoSQL en la seua versi\u00f3 comercial (Enterprise Edition). Nosaltres utilitzarem la que s\u00ed que \u00e9s de codi obert, la Community Edition. Ens ho podem baixar des de la seua p\u00e0gina de desc\u00e0rregues, https://dbeaver.io/download . En el moment de fer aquestos apunts van per la versi\u00f3 24.2.2 La seua instal\u00b7laci\u00f3 no ofereix cap dificultat. En concret, per a Ubuntu, ens ofereix un paquet Debian, que senzillament hem d'instal\u00b7lar com a superusuari. Aquest \u00e9s el seu aspecte: Anem a crear una connexi\u00f3 a PostgeSQL, una altra a MySQL i una altra a SQLite. Quan creem una nova connexi\u00f3 ja podem veure que es pot fer a molts SGBD. En la primera pantalla ja tenim els 3 que volem nosaltres, per\u00f2 hi ha molts m\u00e9s Quan li fa\u00e7a falta un Driver (que per cert seran drivers JDBC) ens preguntar\u00e0 de baixar-lo autom\u00e0ticament, per tant ser\u00e0 comod\u00edssim. PostgreSQL Aquestes s\u00f3n les dades de connexi\u00f3 que farem: Nom de la connexi\u00f3: el que vulguem, per exemple geo_ad Host: 89.36.214.106 Port: 5432 (\u00e9s el port per defecte) Database: geo_ad Usuari: geo_ad Contrasenya: geo_ad I en la pestanya PostgreSQL cuidem de no tenir seleccionada l'opci\u00f3 Show all databases , ja que \u00e9s in\u00fatil mostrar Bases de Dades a les quals no tindrem acc\u00e9s Una vegada creada la connexi\u00f3 podrem navegar fins les taules, i en seleccionar una veurem en 3 pestanyes l'estructura, les dades, i fins i tot un esquema de l'estil del Model Entitat-Relaci\u00f3 (encara que en realitat representa el Model Relacional) on interv\u00e9 la taula, \u00e9s a dir, ens mostra les seues claus externes. Finalment observem com tamb\u00e9 podem executar sent\u00e8ncies SQL de forma molt c\u00f2mode, i on ens d\u00f3na molta ajuda per escriure correctament les paraules reservades i tamb\u00e9 les taules i camps de la nostra BD MySQL Nom de la connexi\u00f3: el que vulgueu, per exemple Connexio MySQL factura Servidor: 89.36.214.106 Port: 3306 Base de dades: factura Usuari: factura Contrasenya: factura La seua utilitzaci\u00f3 \u00e9s igual de f\u00e0cil que en l'anterior cas. SQLite La connexi\u00f3 a SQLite \u00e9s m\u00e9s senzilla i per tant ens preguntar\u00e0 menys coses: Nom de la connexi\u00f3 Ruta i nom del fitxer L'entorn ser\u00e0 totalment similar als dels casos anteriors. Per\u00f2 en aquesta Base de Dades de prova, proveta.sqlite no ten\u00edem cap taula: Aprofitem per a crear una taula, per veure que \u00e9s molt f\u00e0cil i c\u00f2mode. Crearem una taula T1 amb 2 camps, c1 num\u00e8ric, i c2 de text. Potser el menys intu\u00eftiu \u00e9s la manera de crear els camps de la taula. Ser\u00e0 apretant amb el bot\u00f3 de la dreta en la zona de les columnes. En les seg\u00fcents imatges es veu com es creen 2 camps. La tercera \u00e9s en el moment de guardar la taula, i podem comprovar que el que fa \u00e9s generar una consulta SQL Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement CompartirIgual 2.5","title":"4.2 - DBeaver"},{"location":"5__iniciaci_a_lapi_jdbc/","text":"5 - Iniciaci\u00f3 a l'API JDBC \u00b6 Ara veurem els elements b\u00e0sics de l\u2019API JDBC que permeten a les aplicacions Java o Kotlin comunicar-se amb un SGBD fent servir el llenguatge SQL. Cal que disposeu del connector JDBC dels 3 SGDB que anem a utilitzar: PostgreSQL , MySQL i SQLite . Afegirem els 3 connectors a les biblioteques del projecte. Tamb\u00e9 ser\u00e0 necessari connectar des de IntelliJ amb la utilitat que ens ofereix per a veure les Bases de Dades: View - > Tool Windows -> Database , si no disposeu del DBeaver (o clients espac\u00edfics de cada SGBD). Els drivers JDBC per als distints SGBD s\u00f3n molt f\u00e0cils de trobar, fent una senzilla recerca de driver JDBC download i el SGBD que vulgueu. Per m\u00e9s comoditat us pose ac\u00ed els enlla\u00e7os: PostgreSQL: https://jdbc.postgresql.org/download/postgresql-42.2.24.jar MySQL: https://jar-download.com/artifacts/mysql/mysql-connector-java SQLite: https://jar-download.com/artifacts/org.xerial/sqlite-jdbc Tamb\u00e9 teniu, per m\u00e9s comoditat, una carpeta en el curs de Aules amb tots els drivers que ens fan falta Per tal de poder practicar la connexi\u00f3 i accedir a les dades, tenim una Bases de Dades de prova en cada SGBD: PosgreSQL: geo_ad (contrasenya: geo_ad ) MySQL: factura (contrasenya: factura ) SQLite: proveta.sqlite , per\u00f2 en realitat crearem les Bases de Dades que ens facen falta Crearem un projecte nou anomenat Tema4 , per exemple, i li afegirem els controladors JDBC de PostgesSQL , MySQL i SQLite com a biblioteca del projecte. Per a separar les proves dels exercicis, ens creem un paquet anomenat exemples . En la seg\u00fcent imatge es veu com hem incorporat els drivers al projecte (es fa sobre el projecte F4 - > Modules -> Dependencies ) En els punts seg\u00fcents anem a comentar cada cosa per separat, pas a pas. De tota manera, posem la llista inicial de classes que utilitzarem per a poder connectar i accedir a la Base de Dades: Classe Descripci\u00f3 Driver Permet connectar a una Base de Dades DriverManager Permet gestionar tots els drivers instal\u00b7lats al sistema Connection Representa una connexi\u00f3 amb una BD. En una aplicaci\u00f3 pot haver m\u00e9s d'una connexi\u00f3 Statement Permet executar sent\u00e8ncies SQL sense par\u00e0metres PreparedStatement Permet executar sent\u00e8ncies SQL amb par\u00e0metres ResultSet Cont\u00e9 les files resultants d'executar una sent\u00e8ncia SELECT DatabaseMetadata Proporciona informaci\u00f3 d'una BD, com per exemple les taules que cont\u00e9 ResultSetMetadata Proporciona informaci\u00f3 sobre un ResultSet: n\u00famero de columnes, noms de les columnes, tipus, ... 5.1 - Establiment de la connexi\u00f3 \u00b6 Un objecte de la classe Connection (de l'API JDBC) representar\u00e0 una connexi\u00f3 a la Base de Dades d'un determinat SGBD. Haurem de tenir el controlador del SGBD incl\u00f3s en el projecte. L'objecte Connection l'obtindrem a partir del DriverManager , que hav\u00edem comentat que \u00e9s capa\u00e7 de gestionar tots els drivers carregats en mem\u00f2ria. El m\u00e8tode que utilitzarem del DriverManager \u00e9s el getConnection( url , usuari , password ) , on li passarem les dades de connexi\u00f3 a la Base de Dades d'aquesta manera: URL : cadena de connexi\u00f3 seguint el protocol JDBC. Comen\u00e7a sempre per jdbc , el nom del SGBD (separat per dos punts), i la manera d'arribar a la BD, tamb\u00e9 separat per 2 punts. Aquesta manera d'arribar a la BD dependr\u00e0 del controlador del SGBD, per\u00f2 d'alguna manera harem d'especificar el servidor , el port de connexi\u00f3 i el nom de la BD o esquema a connectar. Usuari i contrasenya : encara que en alguns SGBD (com per exemple SQLite) no seran necessaris. Aquestes s\u00f3n les url que utilitzarem: PostgreSQL : per connectar-nos al servidor situal a l'adre\u00e7a 89.36.214.106 , que escolta el port per defecte ( 5432 ), i a la Base de Dades anomenada geo_ad , la cadena ser\u00e0: jdbc:postgresql://89.36.214.106:5432/geo_ad MySQL : el servidor \u00e9s el mateix de PostgreSQL, el port per defecte \u00e9s 3306, i si volem connectar a la Base de Dades factura : jdbc:mysql://89.36.214.106:3306/factura SQLite : no haurem d'especificar ni servidor ni port (ni posteriorment usuari ni contrasenya); \u00fanicament el nom del fitxer amb la ruta. Si volem connectar a la Base de Dades situada en el directori /home/usuari/BD_SQLite , i anomenada proveta.sqlite : jdbc:sqlite:/home/usuari/BD_SQLite/proveta.sqlite __ Mirem tres exemple de connexi\u00f3, un per a cada Base de Dades de prova que tenim en els diferents SGBD que ens hem plantejat connectar. Observeu com nom\u00e9s hem canviat la URL , a banda de l'usuari i contrasenya, clar (en SQLite no hi haur\u00e0). I el millor de tot \u00e9s que una vegada feta la connexi\u00f3, farem el mateix tractament siga quin siga el SGBD al qual ens hem connectat, com veurem amb posterioritat. En aquestos exemples, tan sols fem la connexi\u00f3. Si no es produeix cap error \u00e9s que s'ha pogut connectar. PostgreSQL Guardeu el seg\u00fcent codi en un fitxer Kotlin anomenat Exemple_4_1_ConnexioPostgreSQL.kt : package exemples import java.sql.DriverManager fun main(args: Array<String>) { val url = \"jdbc:postgresql://89.36.214.106:5432/geo_ad\" val usuari = \"geo_ad\" val password = \"geo_ad\" val con = DriverManager.getConnection(url, usuari, password) System.out.println(\"Connexi\u00f3 completada\") con.close() } Si ens hem oblidat d'incorporar el Driver al projecte, ens donar\u00e0 el seg\u00fcent error: que com es veu, ens est\u00e0 indicant que no ha pogut trobar el driver per a eixa URL. Senzillament incorporarem el driver de PostgreSQL en les F4 - > Modules -> Dependencies MySQL Guardeu el seg\u00fcent codi en un fitxer Kotlin anomenat Exemple_4_2_ConnexioMySQL.kt : package exemples import java.sql.DriverManager fun main(args: Array<String>) { val url = \"jdbc:mysql://89.36.214.106:3306/factura\" val usuari = \"factura\" val password = \"factura\" val con = DriverManager.getConnection(url, usuari, password) System.out.println(\"Connexi\u00f3 completada\") con.close() } SQLite Guardeu el seg\u00fcent codi en un fitxer Kotlin anomenat Exemple_4_3_ConnexioSQLite.kt: package exemples import java.sql.DriverManager fun main(args: Array<String>) { val url = \"jdbc:sqlite:proveta.sqlite\" val con = DriverManager.getConnection(url) System.out.println(\"Connexi\u00f3 completada\") con.close() } Com que no hem posat ruta, utilitzar\u00e0 el fitxer proveta.sqlite en el directori actiu, \u00e9s a dir, en l'arrel del projecte. Si no existia, el crear\u00e0. Tamb\u00e9 podr\u00edem posar la ruta d'aquesta manera: String url = \"jdbc:sqlite:/home/usuari/BD_SQLite/proveta.sqlite\"; en aquest cas haureu de cuidar que existesca la ruta del fitxer, sin\u00f3 es produir\u00e0 una SQLException Observem les seg\u00fcents q\u00fcestions en els quatre programes equivalents anteriors: El DriverManager \u00e9s capa\u00e7 de trobar el driver adequat a trav\u00e9s de la url proporcionada (sobretot si el driver est\u00e0 carregat en mem\u00f2ria), i \u00e9s qui ens proporciona l'objecte Connection per mig del m\u00e8tode getConnection() . Hi ha una altra manera d'obtenir el Connection per mig de l'objecte Driver , per\u00f2 tamb\u00e9 ser\u00e0 passant indirectament pel DriverManager . Ens aconformarem amb la manera que hem connectat Si no es troba la classe del driver (per no tenir-lo en les llibreries del projecte, o haver escrit malament el seu nom) es produir\u00e0 l'excepci\u00f3 ClassNotFoundException . Si no es pot establir la connexi\u00f3 per alguna ra\u00f3 es produir\u00e0 l'excepci\u00f3 SQLException . L'objecte Connection mantindr\u00e0 una connexi\u00f3 amb la Base de Dades des del moment de la creaci\u00f3 fins el moment de tancar-la amb close() . \u00c9s molt important tancar la connexi\u00f3, no solament per alliberar la mem\u00f2ria del nostre ordinador (que en tancar l'aplicaci\u00f3 s'alliberaria), sin\u00f3 sobretot per tancar la sessi\u00f3 oberta en el Servidor de Bases de Dades . En el cas de SQLite nom\u00e9s s'ha d'especificar la url . No hem dit ni usuari ni contrasenya, que no tenen sentit en aquest SGBD monousuari. 5.2 - Peticions b\u00e0siques \u00b6 Per escriure sent\u00e8ncies SQL, JDBC disposa dels objectes Statement . Es tracta d\u2019objectes que s'han de crear a partir de Connection , els quals poden enviar sent\u00e8ncies SQL al SGBD connectat per a que s'executen amb el m\u00e8tode executeQuery o executeUpdate . Hi ha una variant del Statement , anomenada PreparedStatement que ens d\u00f3na m\u00e9s versatilitat per a posar par\u00e0metres i executar la sent\u00e8ncia d'una altra manera. El veurem en la pregunta 6.5. La difer\u00e8ncia entre els dos m\u00e8todes que executen sent\u00e8ncies SQL \u00e9s: El m\u00e8tode executeQuery serveix per executar sent\u00e8ncies de les quals s\u2019espera que tornen dades , \u00e9s a dir, s\u00f3n consultes SELECT . En canvi, el m\u00e8tode executeUpdate serveix espec\u00edficament per a sent\u00e8ncies que no retornen dades. Serviran per a modificar la Base de Dades connectada ( INSERT , DELETE , UPDATE , fins i tot CREATE TABLE ) . Sent\u00e8ncies que no retornen dades Les executem amb el m\u00e8tode executeUpdate . Seran totes les sent\u00e8ncies SQL excepte el SELECT , que \u00e9s la de consulta. \u00c9s a dir, ens servir\u00e0 per les seg\u00fcents sent\u00e8ncies: Sent\u00e8ncies que canvien les estructures internes de la BD on es guarden les dades (instruccions conegudes amb les sigles DDL , de l\u2019angl\u00e8s Data Definition Language ), com per exemple CREATE TABLE , CREATE VIEW , ALTER TABLE , DROP TABLE , ..., Sent\u00e8ncies per atorgar permisos als usuaris existents o crear-ne de nous (subgrup d\u2019instruccions conegudes com a DCL o Data Control Language ), com per exemple GRANT . I tamb\u00e9 les sent\u00e8ncies per a modificar les dades guardades fent servir les instruccions INSERT , UPDATE i DELETE . Encara que es tracta de sent\u00e8ncies molt dispars, des del punt de vista de la comunicaci\u00f3 amb el SGBD es comporten de manera molt similar, seguint el patr\u00f3 seg\u00fcent: Instanciaci\u00f3 del Statement a partir d\u2019una connexi\u00f3 activa. Execuci\u00f3 d\u2019una sent\u00e8ncia SQL passada per par\u00e0metre al m\u00e8tode executeUpdate . Tancament de l\u2019objecte Statement instanciat. Mirem aquest exemple, en qual crearem una taula molt senzilla en la Base de Dades SQLite proveta.sqlite . Copieu el seg\u00fcent codi en un fitxer Kotlin anomenat Exemple_4_11_provaSQLIteCreacioTaula.kt : package exemples import java.sql.DriverManager fun main(args: Array<String>) { val url = \"jdbc:sqlite:proveta.sqlite\" val con = DriverManager.getConnection(url) val st = con.createStatement () st.executeUpdate(\"CREATE TABLE T2 (c1 TEXT)\") st.close() con.close() } Des de la perspectiva de Bases de Dades (esquerra) podrem comprovar que ara ja existeix la taula, igual que des del DBeaver (dreta): Sent\u00e8ncies que retornen dades Les executem amb el m\u00e8tode executeQuery . Servir\u00e0 per a la sent\u00e8ncia SELECT , que \u00e9s la de consulta. Les dades que ens torne aquesta sent\u00e8ncia les haurem de guardar en un objecte de la classe ResultSet , \u00e9s a dir conjunt de resultat. Per tant, l\u2019execuci\u00f3 de les consultes tindr\u00e0 un forma semblant a la seg\u00fcent: val rs = st.executeQuery(sentenciaSQL) L\u2019objecte ResultSet cont\u00e9 el resultat de la consulta organitzat per files, de manera que en cada moment es pot consultar una fila . Per a anar visitant totes les files d\u2019una a una, anirem cridant el m\u00e8tode next() de l'objecte ResultSet , ja que cada vegada que s'execute next s\u2019avan\u00e7ar\u00e0 a la seg\u00fcent fila. Immediatament despr\u00e9s d\u2019una execuci\u00f3, el ResultSet es troba posicionat just abans de la primera fila, per tant per accedir a la primera fila caldr\u00e0 executar next una vegada. Quan les files s\u2019acaben, el m\u00e8tode next retornar\u00e0 fals. Des de cada fila es podr\u00e0 accedir al valor de les seues columnes fent servir uns quants m\u00e8todes get disponibles segons el tipus de dades a retornar i passant per par\u00e0metre el n\u00famero de columna que desitgem obtenir. El nom dels m\u00e8todes comen\u00e7a per get seguit del nom del tipus de dades . Aix\u00ed, si volem recuperar la segona columna, sabent que \u00e9s una dada de tipus String caldr\u00e0 executar: rs.getString(2) Les columnes es comencen a comptar a partir del valor 1 ( no zero ). La major part dels SGDB suporten la possibilitat de passar per par\u00e0metre el nom de la columna, per\u00f2 no tots, aix\u00ed que normalment s'opta pel par\u00e0metre num\u00e8ric. En el seg\u00fcent exemple, mostrem el contingut de les dues primeres columnes de la taula INSTITUT de la Base de Dades geo_ad de PostgreSQL , que resulten ser el codi num\u00e8ric de l'Institut i el seu nom. Coieu el seg\u00fcent codi en un fitxer Kotlin anomenat Exemple_4_12_consultaPostgreSQL.kt : package exemples import java.sql.DriverManager fun main(args: Array<String>) { val url = \"jdbc:postgresql://89.36.214.106:5432/geo_ad\" val usuari = \"geo_ad\" val password = \"geo_ad\" val con = DriverManager.getConnection(url, usuari, password) val st = con.createStatement() val rs = st.executeQuery(\"SELECT * FROM institut\") while (rs.next()) { print(\"\" + rs.getInt(1) + \"\\t\") println(rs.getString(2)) } st.close() con.close() } En aquest exemple, on accedim a MySQL , accedirem a una altra taula. Els canvis s\u00f3n els mateixos, la URL, usuari contrasenya i el nom de la taula. Copieu el seg\u00fcent codi en un fitxer Kotlin anomenat Exemple_4_13_consultaMySQL.kt : package exemples import java.sql.DriverManager fun main(args: Array<String>) { val url = \"jdbc:mysql://89.36.214.106:3306/factura\" val usuari = \"factura\" val password = \"factura\" val con = DriverManager.getConnection(url, usuari, password) val st = con.createStatement() val rs = st.executeQuery(\"SELECT * FROM poble\") while (rs.next()) { print(\"\" + rs.getInt(1) + \"\\t\") println(rs.getString(2)) } st.close() con.close() } No reutilitzaci\u00f3 de Statement ni ResultSet \u00c9s un error prou habitual per inesperat el fet d'intentar reutilitzar un mateix ResultSet per a arreplegar m\u00e9s d'una consulta. I el mateix amb el Statement . B\u00e9 siga per una mala implementaci\u00f3 o un bug o el que siga, el comportament pot ser imprevisible. I per tant no val la pena arriscar-se. Us aconselle que si en una aplicaci\u00f3 teniu m\u00e9s d'una consulta de les que retornen dades, utilitzeu un Statement i un ResultSet diferents per a cadascuna . En Kotlin ho podrem aconseguir declarant-los sempre com a val (i no com a var ) No hi ha problema en utilitzar el mateix Statement per a moltes consultes de les que no retornen dades . Assegurar l'alliberament de recursos Les inst\u00e0ncies de Connection i les de Statement guarden, en mem\u00f2ria, molta informaci\u00f3 relacionada amb les execucions realitzades. A m\u00e9s, mentre continuen actives mantenen en el SGBD una sessi\u00f3 oberta, que suposar\u00e0 un conjunt important de recursos oberts, destinats a servir de forma eficient les peticions dels clients. \u00c9s important tancar aquestos objectes per a alliberar recursos tant del client com del servidor. Si en un mateix m\u00e8tode hem de tancar un objecte Statement i el Connection a partir del qual l'hem creat, s'haur\u00e0 de tancar primer el Statement i despr\u00e9s el Connection . Si ho fem al rev\u00e9s, quan intentem tancar el Statement ens saltar\u00e0 una excepci\u00f3 de tipus SQLException , ja que el tancament de la connexi\u00f3 l\u2019hauria deixat inaccessible. A m\u00e9s de respectar l\u2019orde, caldr\u00e0 assegurar l\u2019alliberament dels recursos situant les operacions de tancament dins un bloc finally . D\u2019aquesta manera, encara que es produesquen errors, no es deixaran d\u2019executar les instruccions de tancament. Cal tenir en compte encara un detall m\u00e9s quan siga necessari realitzar el tancament de diversos objectes a la vegada. En aquest cas, encara que les situ\u00e0rem una darrera l\u2019altra, totes les instruccions de tancament dins el bloc finally , no seria prou garantia per assegurar l\u2019execuci\u00f3 de tots els tancaments, ja que, si mentre es produeix el tancament d\u2019un dels objectes es llan\u00e7a una excepci\u00f3, els objectes invocats en una posici\u00f3 posterior a la del que s\u2019ha produ\u00eft l\u2019error no es tancaran. La soluci\u00f3 d\u2019aquest problema passa per evitar el llan\u00e7ament de qualsevol excepci\u00f3 durant el proc\u00e9s de tancament. Una possible forma \u00e9s encapsular cada tancament entre sent\u00e8ncies try-catch dins del finally try{ //_sent\u00e8ncies que poden llan\u00e7ar una excepci\u00f3_ ... } catch (ex: SQLException) { // _captura i tractament de l'excepci\u00f3_ ... }finally{ try { stm1.close() } catch (ex: SQLException) {...} try { stm2.close() } catch (ex: SQLException) {...} ... try { con.close() } catch (ex: SQLException) {...} } De vegades, l\u2019error en un tancament es produeix perqu\u00e8 l\u2019objecte mai ha arribat a instanciar-se i, per tant, la variable presenta un valor null , o perqu\u00e8 ja ha estat tancat amb anterioritat. Ambd\u00f3s casos s\u00f3n previsibles, i es pot evitar l'error fent servir una instrucci\u00f3 condicional que evite tancar-lo quan ja estava tancat. ... try { //_Assegurem que la connexi\u00f3 est\u00e0 instanciada i oberta_ if (con!=null && !con.isClosed() { // _tanquem la connexi\u00f3_ con.close() } } catch (ex: SQLException) { ... } 5.3 - Exemple \u00b6 A continuaci\u00f3 posarem un exemple molt senzill, el dels empleats, en el qual primer crearem la taula per a guardar les dades, despr\u00e9s introduirem les dades, les modificarem, i per \u00faltim les consultarem. D'aquesta manera podrem veure tots els exemples de sent\u00e8ncies SQL. Les dades s\u00f3n les mateixes que en altres ocasions: num nom depart edat sou 1 Andreu 10 32 1000.00 2 Bernat 20 28 1200.00 3 Claudia 10 26 1100.00 4 Dami\u00e0 10 40 1500.00 La clau principal ser\u00e0 el camp num de tipus enter. El nom ser\u00e0 de text, el departament i l'edat tamb\u00e9 enters, mentre que el sou ser\u00e0 real. Per a no interferir entre tots, utilitzarem la Base de Dades SQLite, on cadasc\u00fa guardar\u00e0 en un fitxer seu les dades. Haureu de cuidar la ruta, que siga on voleu guardar la vostra Base de Dades. Si no poseu res en la ruta, es guardar\u00e0 en el directori actiu, que \u00e9s l'arrel del projecte. Creaci\u00f3 de la taula La sent\u00e8ncia SQL que crea la taula en una Base de Dades SQLite ser\u00e0 aix\u00ed: CREATE TABLE EMPLEATS ( num INTEGER CONSTRAINT cp_emp PRIMARY KEY, nom TEXT, depart INTEGER, edat INTEGER, sou REAL ); Hem d'observar que el m\u00e8tode del Statement a utilitzar \u00e9s executeUpdate() , ja que la sent\u00e8ncia de creaci\u00f3 no torna res (no \u00e9s un SELECT) Copieu el seg\u00fcent codi en un fitxer Kotlin anomenat Exemple_4_21_EmpleatsCrearTaula.kt : package exemples import java.sql.DriverManager fun main(args: Array<String>) { val url = \"jdbc:sqlite:Empleats.sqlite\" val con = DriverManager.getConnection(url) val st = con.createStatement() val sentSQL = \"CREATE TABLE EMPLEAT(\" + \"num INTEGER CONSTRAINT cp_emp PRIMARY KEY, \" + \"nom TEXT, \" + \"depart INTEGER, \" + \"edat INTEGER, \" + \"sou REAL \" + \")\" st.executeUpdate(sentSQL) st.close(); con.close() } Si voleu veure el resultat, podeu fer-ho des del DBeaver. Inserci\u00f3 de dades Tamb\u00e9 volem introduir les dades que es poden veure a la taula anterior. Crearem un Statetement que reutilitzarem per anar escrivint totes les sent\u00e8ncies INSERT . Recordeu que no \u00e9s problema la reutilitzaci\u00f3 si gastem el executeUpdate() . Copieu el seg\u00fcent codi en un fitxer Kotlin anomenat Exemple_4_22_EmpleatsInserir.kt : package exemples import java.sql.DriverManager fun main(args: Array<String>) { val url = \"jdbc:sqlite:Empleats.sqlite\" val con = DriverManager.getConnection(url) val st = con.createStatement() st.executeUpdate(\"INSERT INTO EMPLEAT VALUES (1,'Andreu',10,32,1000.0)\") st.executeUpdate(\"INSERT INTO EMPLEAT VALUES (2,'Bernat',20,28,1200.0)\") st.executeUpdate(\"INSERT INTO EMPLEAT VALUES (3,'Cl\u00e0udia',10,26,1100.0)\") st.executeUpdate(\"INSERT INTO EMPLEAT VALUES (4,'Dami\u00e0',10,40,1500.0)\") st.close() con.close() } Ara s\u00ed que \u00e9s un bon moment per a consultar la taula des del DBeaver. Si en ell ja ten\u00edeu oberta la taula, haureu de refrescar. Modificaci\u00f3 de dades Ara modificarem les dades. Senzillament augmentem el sou de tots els empleats en un 5%. I tamb\u00e9 modifiquem el departament de l'empleat 3, posant-li el departament 20. Copieu el seg\u00fcent codi en un fitxer Kotlin anomenat Exemple_4_23_EmpleatsModificar.kt : ackage exemples import java.sql.DriverManager fun main(args: Array<String>) { val url = \"jdbc:sqlite:Empleats.sqlite\" val con = DriverManager.getConnection(url) val st = con.createStatement() st.executeUpdate(\"UPDATE EMPLEAT SET sou = sou * 1.05\") st.executeUpdate(\"UPDATE EMPLEAT SET depart=20 WHERE num = 3\") st.close() con.close() } Consultar les dades Vegem de quina manera podem mostrar per pantalla tots els empleats del que cobren m\u00e9s de 1.100\u20ac. Ara el m\u00e8tode que utilitzarem \u00e9s executeQuery() , ja que aquesta consulta s\u00ed que torna dades. Copieu el seg\u00fcent codi en un fitxer Kotlin anomenat Exemple_4_24_EmpleatsConsultar.kt : package exemples import java.sql.DriverManager fun main(args: Array<String>) { val url = \"jdbc:sqlite:Empleats.sqlite\" val con = DriverManager.getConnection(url) val st = con.createStatement() val sentenciaSQL = \"SELECT * FROM EMPLEAT WHERE sou > 1100\" val rs = st.executeQuery(sentenciaSQL) System.out.println(\"N\u00fam. \\tNom \\tDep \\tEdat \\tSou\") System.out.println(\"-----------------------------------------\") while (rs.next()) { print(\"\" + rs.getInt(1) + \"\\t\") print(rs.getString(2) + \"\\t\") print(\"\" + rs.getInt(3) + \"\\t\") print(\"\" + rs.getInt(4) + \"\\t\") println(rs.getDouble(5)) } rs.close() st.close() con.close() } Podeu observar com es pot usar un bucle while per obtenir el valor de totes les files retornades. Tamb\u00e9 podeu veure els diferents m\u00e8todes que retornen les dades de cada columna en funci\u00f3 del tipus: getInt() , getString() , getDouble() , ... Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement CompartirIgual 2.5","title":"5 - Iniciaci\u00f3 a l'API JDBC"},{"location":"5__iniciaci_a_lapi_jdbc/#5-iniciacio-a-lapi-jdbc","text":"Ara veurem els elements b\u00e0sics de l\u2019API JDBC que permeten a les aplicacions Java o Kotlin comunicar-se amb un SGBD fent servir el llenguatge SQL. Cal que disposeu del connector JDBC dels 3 SGDB que anem a utilitzar: PostgreSQL , MySQL i SQLite . Afegirem els 3 connectors a les biblioteques del projecte. Tamb\u00e9 ser\u00e0 necessari connectar des de IntelliJ amb la utilitat que ens ofereix per a veure les Bases de Dades: View - > Tool Windows -> Database , si no disposeu del DBeaver (o clients espac\u00edfics de cada SGBD). Els drivers JDBC per als distints SGBD s\u00f3n molt f\u00e0cils de trobar, fent una senzilla recerca de driver JDBC download i el SGBD que vulgueu. Per m\u00e9s comoditat us pose ac\u00ed els enlla\u00e7os: PostgreSQL: https://jdbc.postgresql.org/download/postgresql-42.2.24.jar MySQL: https://jar-download.com/artifacts/mysql/mysql-connector-java SQLite: https://jar-download.com/artifacts/org.xerial/sqlite-jdbc Tamb\u00e9 teniu, per m\u00e9s comoditat, una carpeta en el curs de Aules amb tots els drivers que ens fan falta Per tal de poder practicar la connexi\u00f3 i accedir a les dades, tenim una Bases de Dades de prova en cada SGBD: PosgreSQL: geo_ad (contrasenya: geo_ad ) MySQL: factura (contrasenya: factura ) SQLite: proveta.sqlite , per\u00f2 en realitat crearem les Bases de Dades que ens facen falta Crearem un projecte nou anomenat Tema4 , per exemple, i li afegirem els controladors JDBC de PostgesSQL , MySQL i SQLite com a biblioteca del projecte. Per a separar les proves dels exercicis, ens creem un paquet anomenat exemples . En la seg\u00fcent imatge es veu com hem incorporat els drivers al projecte (es fa sobre el projecte F4 - > Modules -> Dependencies ) En els punts seg\u00fcents anem a comentar cada cosa per separat, pas a pas. De tota manera, posem la llista inicial de classes que utilitzarem per a poder connectar i accedir a la Base de Dades: Classe Descripci\u00f3 Driver Permet connectar a una Base de Dades DriverManager Permet gestionar tots els drivers instal\u00b7lats al sistema Connection Representa una connexi\u00f3 amb una BD. En una aplicaci\u00f3 pot haver m\u00e9s d'una connexi\u00f3 Statement Permet executar sent\u00e8ncies SQL sense par\u00e0metres PreparedStatement Permet executar sent\u00e8ncies SQL amb par\u00e0metres ResultSet Cont\u00e9 les files resultants d'executar una sent\u00e8ncia SELECT DatabaseMetadata Proporciona informaci\u00f3 d'una BD, com per exemple les taules que cont\u00e9 ResultSetMetadata Proporciona informaci\u00f3 sobre un ResultSet: n\u00famero de columnes, noms de les columnes, tipus, ...","title":"5 - Iniciaci\u00f3 a l'API JDBC"},{"location":"5__iniciaci_a_lapi_jdbc/#51-establiment-de-la-connexio","text":"Un objecte de la classe Connection (de l'API JDBC) representar\u00e0 una connexi\u00f3 a la Base de Dades d'un determinat SGBD. Haurem de tenir el controlador del SGBD incl\u00f3s en el projecte. L'objecte Connection l'obtindrem a partir del DriverManager , que hav\u00edem comentat que \u00e9s capa\u00e7 de gestionar tots els drivers carregats en mem\u00f2ria. El m\u00e8tode que utilitzarem del DriverManager \u00e9s el getConnection( url , usuari , password ) , on li passarem les dades de connexi\u00f3 a la Base de Dades d'aquesta manera: URL : cadena de connexi\u00f3 seguint el protocol JDBC. Comen\u00e7a sempre per jdbc , el nom del SGBD (separat per dos punts), i la manera d'arribar a la BD, tamb\u00e9 separat per 2 punts. Aquesta manera d'arribar a la BD dependr\u00e0 del controlador del SGBD, per\u00f2 d'alguna manera harem d'especificar el servidor , el port de connexi\u00f3 i el nom de la BD o esquema a connectar. Usuari i contrasenya : encara que en alguns SGBD (com per exemple SQLite) no seran necessaris. Aquestes s\u00f3n les url que utilitzarem: PostgreSQL : per connectar-nos al servidor situal a l'adre\u00e7a 89.36.214.106 , que escolta el port per defecte ( 5432 ), i a la Base de Dades anomenada geo_ad , la cadena ser\u00e0: jdbc:postgresql://89.36.214.106:5432/geo_ad MySQL : el servidor \u00e9s el mateix de PostgreSQL, el port per defecte \u00e9s 3306, i si volem connectar a la Base de Dades factura : jdbc:mysql://89.36.214.106:3306/factura SQLite : no haurem d'especificar ni servidor ni port (ni posteriorment usuari ni contrasenya); \u00fanicament el nom del fitxer amb la ruta. Si volem connectar a la Base de Dades situada en el directori /home/usuari/BD_SQLite , i anomenada proveta.sqlite : jdbc:sqlite:/home/usuari/BD_SQLite/proveta.sqlite __ Mirem tres exemple de connexi\u00f3, un per a cada Base de Dades de prova que tenim en els diferents SGBD que ens hem plantejat connectar. Observeu com nom\u00e9s hem canviat la URL , a banda de l'usuari i contrasenya, clar (en SQLite no hi haur\u00e0). I el millor de tot \u00e9s que una vegada feta la connexi\u00f3, farem el mateix tractament siga quin siga el SGBD al qual ens hem connectat, com veurem amb posterioritat. En aquestos exemples, tan sols fem la connexi\u00f3. Si no es produeix cap error \u00e9s que s'ha pogut connectar. PostgreSQL Guardeu el seg\u00fcent codi en un fitxer Kotlin anomenat Exemple_4_1_ConnexioPostgreSQL.kt : package exemples import java.sql.DriverManager fun main(args: Array<String>) { val url = \"jdbc:postgresql://89.36.214.106:5432/geo_ad\" val usuari = \"geo_ad\" val password = \"geo_ad\" val con = DriverManager.getConnection(url, usuari, password) System.out.println(\"Connexi\u00f3 completada\") con.close() } Si ens hem oblidat d'incorporar el Driver al projecte, ens donar\u00e0 el seg\u00fcent error: que com es veu, ens est\u00e0 indicant que no ha pogut trobar el driver per a eixa URL. Senzillament incorporarem el driver de PostgreSQL en les F4 - > Modules -> Dependencies MySQL Guardeu el seg\u00fcent codi en un fitxer Kotlin anomenat Exemple_4_2_ConnexioMySQL.kt : package exemples import java.sql.DriverManager fun main(args: Array<String>) { val url = \"jdbc:mysql://89.36.214.106:3306/factura\" val usuari = \"factura\" val password = \"factura\" val con = DriverManager.getConnection(url, usuari, password) System.out.println(\"Connexi\u00f3 completada\") con.close() } SQLite Guardeu el seg\u00fcent codi en un fitxer Kotlin anomenat Exemple_4_3_ConnexioSQLite.kt: package exemples import java.sql.DriverManager fun main(args: Array<String>) { val url = \"jdbc:sqlite:proveta.sqlite\" val con = DriverManager.getConnection(url) System.out.println(\"Connexi\u00f3 completada\") con.close() } Com que no hem posat ruta, utilitzar\u00e0 el fitxer proveta.sqlite en el directori actiu, \u00e9s a dir, en l'arrel del projecte. Si no existia, el crear\u00e0. Tamb\u00e9 podr\u00edem posar la ruta d'aquesta manera: String url = \"jdbc:sqlite:/home/usuari/BD_SQLite/proveta.sqlite\"; en aquest cas haureu de cuidar que existesca la ruta del fitxer, sin\u00f3 es produir\u00e0 una SQLException Observem les seg\u00fcents q\u00fcestions en els quatre programes equivalents anteriors: El DriverManager \u00e9s capa\u00e7 de trobar el driver adequat a trav\u00e9s de la url proporcionada (sobretot si el driver est\u00e0 carregat en mem\u00f2ria), i \u00e9s qui ens proporciona l'objecte Connection per mig del m\u00e8tode getConnection() . Hi ha una altra manera d'obtenir el Connection per mig de l'objecte Driver , per\u00f2 tamb\u00e9 ser\u00e0 passant indirectament pel DriverManager . Ens aconformarem amb la manera que hem connectat Si no es troba la classe del driver (per no tenir-lo en les llibreries del projecte, o haver escrit malament el seu nom) es produir\u00e0 l'excepci\u00f3 ClassNotFoundException . Si no es pot establir la connexi\u00f3 per alguna ra\u00f3 es produir\u00e0 l'excepci\u00f3 SQLException . L'objecte Connection mantindr\u00e0 una connexi\u00f3 amb la Base de Dades des del moment de la creaci\u00f3 fins el moment de tancar-la amb close() . \u00c9s molt important tancar la connexi\u00f3, no solament per alliberar la mem\u00f2ria del nostre ordinador (que en tancar l'aplicaci\u00f3 s'alliberaria), sin\u00f3 sobretot per tancar la sessi\u00f3 oberta en el Servidor de Bases de Dades . En el cas de SQLite nom\u00e9s s'ha d'especificar la url . No hem dit ni usuari ni contrasenya, que no tenen sentit en aquest SGBD monousuari.","title":"5.1 - Establiment de la connexi\u00f3"},{"location":"5__iniciaci_a_lapi_jdbc/#52-peticions-basiques","text":"Per escriure sent\u00e8ncies SQL, JDBC disposa dels objectes Statement . Es tracta d\u2019objectes que s'han de crear a partir de Connection , els quals poden enviar sent\u00e8ncies SQL al SGBD connectat per a que s'executen amb el m\u00e8tode executeQuery o executeUpdate . Hi ha una variant del Statement , anomenada PreparedStatement que ens d\u00f3na m\u00e9s versatilitat per a posar par\u00e0metres i executar la sent\u00e8ncia d'una altra manera. El veurem en la pregunta 6.5. La difer\u00e8ncia entre els dos m\u00e8todes que executen sent\u00e8ncies SQL \u00e9s: El m\u00e8tode executeQuery serveix per executar sent\u00e8ncies de les quals s\u2019espera que tornen dades , \u00e9s a dir, s\u00f3n consultes SELECT . En canvi, el m\u00e8tode executeUpdate serveix espec\u00edficament per a sent\u00e8ncies que no retornen dades. Serviran per a modificar la Base de Dades connectada ( INSERT , DELETE , UPDATE , fins i tot CREATE TABLE ) . Sent\u00e8ncies que no retornen dades Les executem amb el m\u00e8tode executeUpdate . Seran totes les sent\u00e8ncies SQL excepte el SELECT , que \u00e9s la de consulta. \u00c9s a dir, ens servir\u00e0 per les seg\u00fcents sent\u00e8ncies: Sent\u00e8ncies que canvien les estructures internes de la BD on es guarden les dades (instruccions conegudes amb les sigles DDL , de l\u2019angl\u00e8s Data Definition Language ), com per exemple CREATE TABLE , CREATE VIEW , ALTER TABLE , DROP TABLE , ..., Sent\u00e8ncies per atorgar permisos als usuaris existents o crear-ne de nous (subgrup d\u2019instruccions conegudes com a DCL o Data Control Language ), com per exemple GRANT . I tamb\u00e9 les sent\u00e8ncies per a modificar les dades guardades fent servir les instruccions INSERT , UPDATE i DELETE . Encara que es tracta de sent\u00e8ncies molt dispars, des del punt de vista de la comunicaci\u00f3 amb el SGBD es comporten de manera molt similar, seguint el patr\u00f3 seg\u00fcent: Instanciaci\u00f3 del Statement a partir d\u2019una connexi\u00f3 activa. Execuci\u00f3 d\u2019una sent\u00e8ncia SQL passada per par\u00e0metre al m\u00e8tode executeUpdate . Tancament de l\u2019objecte Statement instanciat. Mirem aquest exemple, en qual crearem una taula molt senzilla en la Base de Dades SQLite proveta.sqlite . Copieu el seg\u00fcent codi en un fitxer Kotlin anomenat Exemple_4_11_provaSQLIteCreacioTaula.kt : package exemples import java.sql.DriverManager fun main(args: Array<String>) { val url = \"jdbc:sqlite:proveta.sqlite\" val con = DriverManager.getConnection(url) val st = con.createStatement () st.executeUpdate(\"CREATE TABLE T2 (c1 TEXT)\") st.close() con.close() } Des de la perspectiva de Bases de Dades (esquerra) podrem comprovar que ara ja existeix la taula, igual que des del DBeaver (dreta): Sent\u00e8ncies que retornen dades Les executem amb el m\u00e8tode executeQuery . Servir\u00e0 per a la sent\u00e8ncia SELECT , que \u00e9s la de consulta. Les dades que ens torne aquesta sent\u00e8ncia les haurem de guardar en un objecte de la classe ResultSet , \u00e9s a dir conjunt de resultat. Per tant, l\u2019execuci\u00f3 de les consultes tindr\u00e0 un forma semblant a la seg\u00fcent: val rs = st.executeQuery(sentenciaSQL) L\u2019objecte ResultSet cont\u00e9 el resultat de la consulta organitzat per files, de manera que en cada moment es pot consultar una fila . Per a anar visitant totes les files d\u2019una a una, anirem cridant el m\u00e8tode next() de l'objecte ResultSet , ja que cada vegada que s'execute next s\u2019avan\u00e7ar\u00e0 a la seg\u00fcent fila. Immediatament despr\u00e9s d\u2019una execuci\u00f3, el ResultSet es troba posicionat just abans de la primera fila, per tant per accedir a la primera fila caldr\u00e0 executar next una vegada. Quan les files s\u2019acaben, el m\u00e8tode next retornar\u00e0 fals. Des de cada fila es podr\u00e0 accedir al valor de les seues columnes fent servir uns quants m\u00e8todes get disponibles segons el tipus de dades a retornar i passant per par\u00e0metre el n\u00famero de columna que desitgem obtenir. El nom dels m\u00e8todes comen\u00e7a per get seguit del nom del tipus de dades . Aix\u00ed, si volem recuperar la segona columna, sabent que \u00e9s una dada de tipus String caldr\u00e0 executar: rs.getString(2) Les columnes es comencen a comptar a partir del valor 1 ( no zero ). La major part dels SGDB suporten la possibilitat de passar per par\u00e0metre el nom de la columna, per\u00f2 no tots, aix\u00ed que normalment s'opta pel par\u00e0metre num\u00e8ric. En el seg\u00fcent exemple, mostrem el contingut de les dues primeres columnes de la taula INSTITUT de la Base de Dades geo_ad de PostgreSQL , que resulten ser el codi num\u00e8ric de l'Institut i el seu nom. Coieu el seg\u00fcent codi en un fitxer Kotlin anomenat Exemple_4_12_consultaPostgreSQL.kt : package exemples import java.sql.DriverManager fun main(args: Array<String>) { val url = \"jdbc:postgresql://89.36.214.106:5432/geo_ad\" val usuari = \"geo_ad\" val password = \"geo_ad\" val con = DriverManager.getConnection(url, usuari, password) val st = con.createStatement() val rs = st.executeQuery(\"SELECT * FROM institut\") while (rs.next()) { print(\"\" + rs.getInt(1) + \"\\t\") println(rs.getString(2)) } st.close() con.close() } En aquest exemple, on accedim a MySQL , accedirem a una altra taula. Els canvis s\u00f3n els mateixos, la URL, usuari contrasenya i el nom de la taula. Copieu el seg\u00fcent codi en un fitxer Kotlin anomenat Exemple_4_13_consultaMySQL.kt : package exemples import java.sql.DriverManager fun main(args: Array<String>) { val url = \"jdbc:mysql://89.36.214.106:3306/factura\" val usuari = \"factura\" val password = \"factura\" val con = DriverManager.getConnection(url, usuari, password) val st = con.createStatement() val rs = st.executeQuery(\"SELECT * FROM poble\") while (rs.next()) { print(\"\" + rs.getInt(1) + \"\\t\") println(rs.getString(2)) } st.close() con.close() } No reutilitzaci\u00f3 de Statement ni ResultSet \u00c9s un error prou habitual per inesperat el fet d'intentar reutilitzar un mateix ResultSet per a arreplegar m\u00e9s d'una consulta. I el mateix amb el Statement . B\u00e9 siga per una mala implementaci\u00f3 o un bug o el que siga, el comportament pot ser imprevisible. I per tant no val la pena arriscar-se. Us aconselle que si en una aplicaci\u00f3 teniu m\u00e9s d'una consulta de les que retornen dades, utilitzeu un Statement i un ResultSet diferents per a cadascuna . En Kotlin ho podrem aconseguir declarant-los sempre com a val (i no com a var ) No hi ha problema en utilitzar el mateix Statement per a moltes consultes de les que no retornen dades . Assegurar l'alliberament de recursos Les inst\u00e0ncies de Connection i les de Statement guarden, en mem\u00f2ria, molta informaci\u00f3 relacionada amb les execucions realitzades. A m\u00e9s, mentre continuen actives mantenen en el SGBD una sessi\u00f3 oberta, que suposar\u00e0 un conjunt important de recursos oberts, destinats a servir de forma eficient les peticions dels clients. \u00c9s important tancar aquestos objectes per a alliberar recursos tant del client com del servidor. Si en un mateix m\u00e8tode hem de tancar un objecte Statement i el Connection a partir del qual l'hem creat, s'haur\u00e0 de tancar primer el Statement i despr\u00e9s el Connection . Si ho fem al rev\u00e9s, quan intentem tancar el Statement ens saltar\u00e0 una excepci\u00f3 de tipus SQLException , ja que el tancament de la connexi\u00f3 l\u2019hauria deixat inaccessible. A m\u00e9s de respectar l\u2019orde, caldr\u00e0 assegurar l\u2019alliberament dels recursos situant les operacions de tancament dins un bloc finally . D\u2019aquesta manera, encara que es produesquen errors, no es deixaran d\u2019executar les instruccions de tancament. Cal tenir en compte encara un detall m\u00e9s quan siga necessari realitzar el tancament de diversos objectes a la vegada. En aquest cas, encara que les situ\u00e0rem una darrera l\u2019altra, totes les instruccions de tancament dins el bloc finally , no seria prou garantia per assegurar l\u2019execuci\u00f3 de tots els tancaments, ja que, si mentre es produeix el tancament d\u2019un dels objectes es llan\u00e7a una excepci\u00f3, els objectes invocats en una posici\u00f3 posterior a la del que s\u2019ha produ\u00eft l\u2019error no es tancaran. La soluci\u00f3 d\u2019aquest problema passa per evitar el llan\u00e7ament de qualsevol excepci\u00f3 durant el proc\u00e9s de tancament. Una possible forma \u00e9s encapsular cada tancament entre sent\u00e8ncies try-catch dins del finally try{ //_sent\u00e8ncies que poden llan\u00e7ar una excepci\u00f3_ ... } catch (ex: SQLException) { // _captura i tractament de l'excepci\u00f3_ ... }finally{ try { stm1.close() } catch (ex: SQLException) {...} try { stm2.close() } catch (ex: SQLException) {...} ... try { con.close() } catch (ex: SQLException) {...} } De vegades, l\u2019error en un tancament es produeix perqu\u00e8 l\u2019objecte mai ha arribat a instanciar-se i, per tant, la variable presenta un valor null , o perqu\u00e8 ja ha estat tancat amb anterioritat. Ambd\u00f3s casos s\u00f3n previsibles, i es pot evitar l'error fent servir una instrucci\u00f3 condicional que evite tancar-lo quan ja estava tancat. ... try { //_Assegurem que la connexi\u00f3 est\u00e0 instanciada i oberta_ if (con!=null && !con.isClosed() { // _tanquem la connexi\u00f3_ con.close() } } catch (ex: SQLException) { ... }","title":"5.2 - Peticions b\u00e0siques"},{"location":"5__iniciaci_a_lapi_jdbc/#53-exemple","text":"A continuaci\u00f3 posarem un exemple molt senzill, el dels empleats, en el qual primer crearem la taula per a guardar les dades, despr\u00e9s introduirem les dades, les modificarem, i per \u00faltim les consultarem. D'aquesta manera podrem veure tots els exemples de sent\u00e8ncies SQL. Les dades s\u00f3n les mateixes que en altres ocasions: num nom depart edat sou 1 Andreu 10 32 1000.00 2 Bernat 20 28 1200.00 3 Claudia 10 26 1100.00 4 Dami\u00e0 10 40 1500.00 La clau principal ser\u00e0 el camp num de tipus enter. El nom ser\u00e0 de text, el departament i l'edat tamb\u00e9 enters, mentre que el sou ser\u00e0 real. Per a no interferir entre tots, utilitzarem la Base de Dades SQLite, on cadasc\u00fa guardar\u00e0 en un fitxer seu les dades. Haureu de cuidar la ruta, que siga on voleu guardar la vostra Base de Dades. Si no poseu res en la ruta, es guardar\u00e0 en el directori actiu, que \u00e9s l'arrel del projecte. Creaci\u00f3 de la taula La sent\u00e8ncia SQL que crea la taula en una Base de Dades SQLite ser\u00e0 aix\u00ed: CREATE TABLE EMPLEATS ( num INTEGER CONSTRAINT cp_emp PRIMARY KEY, nom TEXT, depart INTEGER, edat INTEGER, sou REAL ); Hem d'observar que el m\u00e8tode del Statement a utilitzar \u00e9s executeUpdate() , ja que la sent\u00e8ncia de creaci\u00f3 no torna res (no \u00e9s un SELECT) Copieu el seg\u00fcent codi en un fitxer Kotlin anomenat Exemple_4_21_EmpleatsCrearTaula.kt : package exemples import java.sql.DriverManager fun main(args: Array<String>) { val url = \"jdbc:sqlite:Empleats.sqlite\" val con = DriverManager.getConnection(url) val st = con.createStatement() val sentSQL = \"CREATE TABLE EMPLEAT(\" + \"num INTEGER CONSTRAINT cp_emp PRIMARY KEY, \" + \"nom TEXT, \" + \"depart INTEGER, \" + \"edat INTEGER, \" + \"sou REAL \" + \")\" st.executeUpdate(sentSQL) st.close(); con.close() } Si voleu veure el resultat, podeu fer-ho des del DBeaver. Inserci\u00f3 de dades Tamb\u00e9 volem introduir les dades que es poden veure a la taula anterior. Crearem un Statetement que reutilitzarem per anar escrivint totes les sent\u00e8ncies INSERT . Recordeu que no \u00e9s problema la reutilitzaci\u00f3 si gastem el executeUpdate() . Copieu el seg\u00fcent codi en un fitxer Kotlin anomenat Exemple_4_22_EmpleatsInserir.kt : package exemples import java.sql.DriverManager fun main(args: Array<String>) { val url = \"jdbc:sqlite:Empleats.sqlite\" val con = DriverManager.getConnection(url) val st = con.createStatement() st.executeUpdate(\"INSERT INTO EMPLEAT VALUES (1,'Andreu',10,32,1000.0)\") st.executeUpdate(\"INSERT INTO EMPLEAT VALUES (2,'Bernat',20,28,1200.0)\") st.executeUpdate(\"INSERT INTO EMPLEAT VALUES (3,'Cl\u00e0udia',10,26,1100.0)\") st.executeUpdate(\"INSERT INTO EMPLEAT VALUES (4,'Dami\u00e0',10,40,1500.0)\") st.close() con.close() } Ara s\u00ed que \u00e9s un bon moment per a consultar la taula des del DBeaver. Si en ell ja ten\u00edeu oberta la taula, haureu de refrescar. Modificaci\u00f3 de dades Ara modificarem les dades. Senzillament augmentem el sou de tots els empleats en un 5%. I tamb\u00e9 modifiquem el departament de l'empleat 3, posant-li el departament 20. Copieu el seg\u00fcent codi en un fitxer Kotlin anomenat Exemple_4_23_EmpleatsModificar.kt : ackage exemples import java.sql.DriverManager fun main(args: Array<String>) { val url = \"jdbc:sqlite:Empleats.sqlite\" val con = DriverManager.getConnection(url) val st = con.createStatement() st.executeUpdate(\"UPDATE EMPLEAT SET sou = sou * 1.05\") st.executeUpdate(\"UPDATE EMPLEAT SET depart=20 WHERE num = 3\") st.close() con.close() } Consultar les dades Vegem de quina manera podem mostrar per pantalla tots els empleats del que cobren m\u00e9s de 1.100\u20ac. Ara el m\u00e8tode que utilitzarem \u00e9s executeQuery() , ja que aquesta consulta s\u00ed que torna dades. Copieu el seg\u00fcent codi en un fitxer Kotlin anomenat Exemple_4_24_EmpleatsConsultar.kt : package exemples import java.sql.DriverManager fun main(args: Array<String>) { val url = \"jdbc:sqlite:Empleats.sqlite\" val con = DriverManager.getConnection(url) val st = con.createStatement() val sentenciaSQL = \"SELECT * FROM EMPLEAT WHERE sou > 1100\" val rs = st.executeQuery(sentenciaSQL) System.out.println(\"N\u00fam. \\tNom \\tDep \\tEdat \\tSou\") System.out.println(\"-----------------------------------------\") while (rs.next()) { print(\"\" + rs.getInt(1) + \"\\t\") print(rs.getString(2) + \"\\t\") print(\"\" + rs.getInt(3) + \"\\t\") print(\"\" + rs.getInt(4) + \"\\t\") println(rs.getDouble(5)) } rs.close() st.close() con.close() } Podeu observar com es pot usar un bucle while per obtenir el valor de totes les files retornades. Tamb\u00e9 podeu veure els diferents m\u00e8todes que retornen les dades de cada columna en funci\u00f3 del tipus: getInt() , getString() , getDouble() , ... Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement CompartirIgual 2.5","title":"5.3 - Exemple"},{"location":"6__jdbc_avanat/","text":"6 - JDBC avan\u00e7at \u00b6 JDBC disposa d\u2019una alta funcionalitat i estructures que poden ajudar-nos a incrementar la qualitat de les aplicacions que constru\u00efm. La primera \u00e9s poder accedir no a les dades, sin\u00f3 a les estructures de les dades, \u00e9s a dir, l'estructura de les taules o de les consultes que fem: noms de les columnes, tipus, etc. En definitiva \u00e9s accedir a les Metadades. Tamb\u00e9 seria convenient construir aplicacions flexibles, robustes i eficients. Necessitarem, doncs, un bon tractament d\u2019errors que trasllade quan fa\u00e7a falta la informaci\u00f3 adequada a l\u2019usuari o reconduint el flux de l\u2019execuci\u00f3 cap a processos que interpreten i compensen els errors. L\u2019efici\u00e8ncia \u00e9s tamb\u00e9 una caracter\u00edstica important de la qualitat. En general, els Sistemes Gestors de Bases de Dades disposen de mecanismes autom\u00e0tics per potenciar l\u2019efici\u00e8ncia de les peticions, com ara l\u2019\u00fas de mem\u00f2ria cach\u00e9 d\u2019acc\u00e9s r\u00e0pid, la creaci\u00f3 d\u2019\u00edndexs autom\u00e0tics, etc. Aquestos automatismes responen a determinats patrons a l\u2019hora de fer les peticions. Per aix\u00f2 JDBC preveu altres formes, diferents a les estudiades fins ara, per realitzar peticions que milloren el rendiment. 6.1 - Acc\u00e9s a les Meta Dades \u00b6 Normalment quan accedim a una Base de Dades des d'un programa Java, coneixerem l'estructura d'aquesta Base de Dades, \u00e9s a dir, les taules que t\u00e9 i cada taula quins camps i de quin tipus s\u00f3n. I fins i tot les claus externes entre les taules. Per\u00f2 podria passar que no conegu\u00e9rem aquesta estructura. Aix\u00f2 no hauria de ser un problema per accedir a la Base de Dades, ja que aquesta \u00e9s autodescriptiva, \u00e9s a dir, que hem de poder consultar a la Base de Dades per a que ens diga la seua estructura. L'objecte que ens d\u00f3na aquesta informaci\u00f3 \u00e9s el DatabaseMetaData . Disposa de molts m\u00e8todes que ens proporcionen gran quantitat d'informaci\u00f3. I tamb\u00e9 ens d\u00f3na informaci\u00f3 un altre objecte, ResultSetMetaData , que obtindr\u00e0 la informaci\u00f3 a partir d'un ResultSet . Veurem els dos per separat. DatabaseMetaData \u00c9s l'adequat quan volem veure les taules i vistes que tenim en la Base de Dades, aix\u00ed com l'estructura de cadascuna d'elles. Mirem primer els m\u00e8todes m\u00e9s interessants que t\u00e9: Valor tornat Nom del m\u00e8tode Descripci\u00f3 String getDatabaseProductName() Torna el nom del SGBD String getDriverName() Torna el driver JDBC utilitzat String getURL() Torna la URL de la connexi\u00f3 String getUserName() Torna el nom de l'usuari que s'ha connectat ResultSet getTables(cataleg, esquema, nom, tipus) Torna informaci\u00f3 de totes les taules que coincideixen amb els patrons o criteris. Si posem null a tots els par\u00e0metres ens tornar\u00e0 totes les taules i vistes ResultSet getColumns(cataleg, esquema, nom, nom_colu) Torna informaci\u00f3 de les columnes de la taula especificada en el tercer par\u00e0metre (que est\u00e0 en el cat\u00e0leg i en l'esquema, si els posem). El quart par\u00e0metre servir\u00e0 per a seleccionar les columnes que coincidesquen amb el patr\u00f3 (null per a totes) ResultSet getPrimaryKeys(cataleg, esquema, taula) Torna la llista de camps que formen la clau principal ResultSet getImportedKeys(cataleg, esquema, taula) Torna una llista amb les claus externes definides en aquesta taula ResultSet getExportedKeys(cataleg, esquema, taula) Torna una llista amb les claus externes que apunten a aquesta taula Per poder comprovar tot l'anterior, farem un programa que ens done informaci\u00f3 de la Base de Dades, una relaci\u00f3 de les taules i vistes que t\u00e9. Posteriorment acceptar\u00e0 un n\u00famero, i traur\u00e0 la informaci\u00f3 de la taula corresponent amb aquest format: columnes, tipus, clau principal, claus externes. Copieu elseg\u00fcent codi en un fitxer Kotlin anomenat Exemple_4_31_MetaData.kt : package exemples import java.sql.DriverManager import java.io.BufferedReader import java.io.InputStreamReader fun main(args: Array<String>) { val con = DriverManager.getConnection (\"jdbc:postgresql://89.36.214.106:5432/geo_ad\", \"geo_ad\", \"geo_ad\") val dbmd = con.getMetaData () println(\"Informaci\u00f3 general\") println(\"------------------\") println(\"SGBD \" + dbmd.getDatabaseProductName()) println(\"Driver \" + dbmd.getDriverName()) println(\"URL \" + dbmd.getURL()) println(\"Usuari \" + dbmd.getUserName()) println() println(\"Llistat de taules\") println(String.format(\"%-6s %-7s %-7s %-10s %-10s\", \"N\u00famero\", \"Cat\u00e0leg\", \"Esquema\", \"Nom\", \"Tipus\")) println(\"---------------------------------------------\") val ll = dbmd.getTables(null, \"public\", null, null) var compt = 1 val taules = ArrayList<String>() while (ll.next()) { println(String.format(\"%-6d %-7s %-7s %-10s %-10s\",(compt++),ll.getString(1),ll.getString(2),ll.getString(3),ll.getString(4))) taules.add(ll.getString(3)) } println() println(\"Introdueix un n\u00famero per veure l'estructura de la taula (0 per acabar) \") val ent = BufferedReader(InputStreamReader (System.`in`)) var opcio = Integer.parseInt(ent.readLine()) while (opcio != 0) { if (opcio < compt && opcio > 0) { val taula = dbmd.getTables (null, \"public\", taules.get(opcio-1), null) if (taula.next()) { if (taula.getString(4).equals(\"TABLE\")) { val rs = dbmd.getColumns (null, \"public\", taules.get(opcio-1), null) println(\"Estructura de la taula \" + taules.get(opcio - 1)) println(\"----------------------------\") while (rs.next()) println(rs.getString(4) + \" (\" + rs.getString(6) + \")\") println(\"----------------------------\") val rs2 = dbmd.getPrimaryKeys(null, \"public\", taules.get(opcio - 1)) print(\"Clau principal \") while (rs2.next()) print(rs2.getString(4) + \" \") println() val rs3 = dbmd.getImportedKeys(null, \"public\", taules.get(opcio - 1)) println(\"Claus externes \") while (rs3.next()) { println(rs3.getString(8) + \" apunta a \" + rs3.getString(3)) } rs.close() rs2.close() rs3.close() } } taula.close() } println() println(\"Introdueix un n\u00famero per veure l'estructura de la taula (0 per acabar) \") opcio = Integer.parseInt(ent.readLine()) } ll.close() con.close() } ResultSetMetaData Una vegada executada una sent\u00e8ncia SELECT de SQL que ja tenim el resultat en un ResultSet, podem accedir tamb\u00e9 a meta dades d'aquest ResultSet, obtenint per exemple el n\u00famero de columnes, o el tipus de les columnes. Ho obtenim per mig del ResulSetMetaData . Nom\u00e9s veurem 3 m\u00e8todes Valor tornat Nom del m\u00e8tode Descripci\u00f3 int getColumnCount() Torna el n\u00famero de columnes del ResultSet String getColumnName(index) Torna el nom de la columna (la primera columna \u00e9s la 1) String getColumnTypeName(index) Torna el tipus de la columna El seg\u00fcent exemple \u00e9s una modificaci\u00f3 del programa anterior, on ara traurem tot el contingut d'una taula per mig de la sent\u00e8ncia SELECT * FROM taula . Intentarem donar-li un aspecte tabular, per\u00f2 sense patir molt per l'aspecte. Copieu el seg\u00fcent codi en un fitxer Kotlin anomenat Exemple_4_32_ResultSetMetaData.kt : package exemples import java.sql.DriverManager import java.io.BufferedReader import java.io.InputStreamReader fun main(args: Array<String>) { val con = DriverManager.getConnection(\"jdbc:postgresql://89.36.214.106:5432/geo_ad\", \"geo_ad\", \"geo_ad\") val dbmd = con.getMetaData() println(\"Llistat de taules:\") println(String.format(\"%-6s %-7s %-7s %-10s %-10s\", \"N\u00famero\", \"Cat\u00e0leg\", \"Esquema\", \"Nom\", \"Tipus\")) println(\"---------------------------------------------\") val ll = dbmd.getTables(null, \"public\", null, null) var compt = 1 val taules = ArrayList<String>() while (ll.next()) { println(String.format(\"%-6d %-7s %-7s %-10s %-10s\",(compt++),ll.getString(1),ll.getString(2), ll.getString(3),ll.getString(4))) taules.add(ll.getString(3)) } println() println(\"Introdueix un n\u00famero per veure el contingut de la taula (0 per acabar): \") val ent = BufferedReader(InputStreamReader(System.`in`)) var opcio = Integer.parseInt(ent.readLine()) while (opcio != 0) { if (opcio < compt && opcio > 0) { val taula = dbmd.getTables(null, \"public\", taules.get(opcio - 1), null) if (taula.next()) { if (taula.getString(4).equals(\"TABLE\")) { val rs = con.createStatement().executeQuery(\"SELECT * FROM \" + taules.get(opcio - 1) + \" ORDER BY 1\") println(\"Contingut de la taula \" + taules.get(opcio - 1)) println(\"----------------------------\") val rsmd = rs.getMetaData() for (i in 1..rsmd.getColumnCount()) print(String.format(\"%-20.20s\", rsmd.getColumnName(i))) println() println(\"------------------------------------------\") while (rs.next()) { for (i in 1..rsmd.getColumnCount()) print(String.format(\"%-20.20s \", rs.getString(i))) println() } rs.close() } } taula.close() } println() println(\"Introdueix un n\u00famero per veure el contingut de la taula (0 per acabar): \") opcio = Integer.parseInt(ent.readLine()) } ll.close() con.close() } 6.2 - ResultSets que poden avan\u00e7ar cap avant i cap arrere \u00b6 Fins el moment, tots els ResultSet que hem creat podien avan\u00e7ar \u00fanicament cap avant, fent un recorregut seq\u00fcencial de les dades. Inicialment el punter que apunta a l'estructura est\u00e0 situat abans de la primera fila En fer next() se situa a la seg\u00fcent fila (la primera vegada se situa en la primera fila) Quan estiguem situats en l'\u00faltima fima, si fem next() se situara despr\u00e9s de l'\u00faltima, i ho indicar\u00e0 tornant false Per\u00f2 aquesta manera de funcionar, que es diu TYPE_FORWARD_ONLY i que \u00e9s l'opci\u00f3 per defecte per a obrir un ResultSet, no \u00e9s l'\u00fanica. Aquestos s\u00f3n els tipus de ResultSet que hi ha: TYPE_FORWARD_ONLY : \u00e9s el tipus utilitzat fins el moment, i \u00e9s el tipus per defecte. El ResultSet nom\u00e9s pot avan\u00e7ar cap avant. TYPE_SCROLL_INSENSITIVE : El ResultSet pot avan\u00e7ar cap avant i cap arrere, fins i tot pot anar a una posici\u00f3 absoluta (directament, sense passar per les anteriors). El ResultSet no \u00e9s sensible als canvis fets en les dades que han proporcionat aquest resultat, \u00e9s a dir, ens mostra les dades que hi havia en el moment d'executar la consulta, sense poder mostrar possibles canvis posteriors. TYPE_SCROLL_SENSITIVE : Igual que l'anterior en quant al moviment. Per\u00f2 ara s\u00ed que \u00e9s capa\u00e7 de mostrar possibles canvies fets en les dades originals posteriors al moment de l'execuci\u00f3 de la consulta, mentre el ResultSet estiga obert. I per una altra banda el ResultSet pot tenir la possibilitat d' actualitzar les dades originals. Des d'aquest punt de vista hi ha 2 possibles tipus: CONCUR_READ_ONLY : El ResultSet nom\u00e9s \u00e9s de lectura i no es pot actualitzar CONCUR_UPDATABLE : El ResultSet es pot actualitzar (i els canvis es reflectiran en les dades originals) utilitzant el mateix ResultSet L'opci\u00f3 per defecte \u00e9s CONCUR_READ_ONLY Realment on declararem els tipus \u00e9s en la creaci\u00f3 del STATEMENT a partir del qual crearem la sent\u00e8ncia que omplir\u00e0 el ResultSet . \u00c9s l\u00f2gic, ja que aquestes maneres de funcionar s'han de preparar abans d'executar la sent\u00e8ncia. Fins ara no hav\u00edem posat par\u00e0metres en la creaci\u00f3 del Statement , cosa que fa que es cree amb les opcions per defecte. Si volem altres opcions: val st =con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY) val st =con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE,ResultSet.CONCUR_UPDATABLE) La primera q\u00fcesti\u00f3 que hem de comentar \u00e9s que el SGBD ha de ser capa\u00e7 de suportar els tipus que no s\u00f3n per defecte, i no sempre \u00e9s aix\u00ed. Mentre que PostgreSQL , Oracle i MySQL s\u00ed que s\u00f3n capa\u00e7os de suportar tots els tipus anteriors, SQLite no ho pot fer i tan sols suporta TYPE_FORWARD_ONLY i CONCUR_READ_ONLY , com era d'esperar. Deixant de banda la possibilitat de reflectir els possibles canvis de les dades originals ( SENSITIVE ), i de poder actualitzar-les ( CONCUR_UPDATABLE ), anem a estudiar els possibles moviments dins del ResultSet . next : Avan\u00e7a una fila cap avant. Torna true si s'ha pogut posicionar, i false si no s'ha pogut posicionar, per estar despr\u00e9s de l'\u00faltima fila. previous : Avan\u00e7a una fila cap arrere. Torna true si s'ha pogut posicionar, i false si no s'ha pogut posicionar, per estar abans de la primera fila. first : Se situa en la primera fila. Torna true si s'ha pogut posicionar, i false si no s'ha pogut posicionar, per no contenir el ResultSet cap fila. last: : Se situa en l'\u00faltima fila. Torna true si s'ha pogut posicionar, i false si no s'ha pogut posicionar, per no contenir el ResultSet cap fila. beforeFirst : Se situa al principi del RecordSet, abans de la primera fila. Si no hi havia cap fila, no fa res. afterLast : Se situa al final del RecordSet, despr\u00e9s de l'\u00faltima fila. Si no hi havia cap fila, no fa res. relative(int files ) : Meneja el cursor respecte de la posici\u00f3 actual, tantes files com s'indica en el par\u00e0metre (si el par\u00e0metre \u00e9s negatiu, anir\u00e0 cap arrere). absolute(int fila ) : Situa el cursor en la fila especificada en el par\u00e0metre (1 \u00e9s la primera) El seg\u00fcent exemple es practica anar a la primera, a l'anterior, a la seg\u00fcent i a l'\u00faltima fila. Copieu el seg\u00fcent codi en un fitxer Kotlin anomenat Exemple_4_41_Scroll.kt : package exemples import javax.swing.JFrame import javax.swing.JLabel import javax.swing.JTextField import javax.swing.JButton import javax.swing.JPanel import java.awt.FlowLayout import java.awt.GridLayout import java.awt.BorderLayout import java.awt.EventQueue import java.sql.DriverManager import java.sql.ResultSet class Exemple_4_41_Scroll : JFrame() { val nomComarca = JTextField() val nomProvincia = JTextField() val primer = JButton(\"<<\") val anterior = JButton(\"<\") val seguent = JButton(\">\") val ultim = JButton(\">>\") val tancar = JButton(\"Tancar\") val pDalt = JPanel(FlowLayout()) val pCentre = JPanel(GridLayout(8, 0)) val pDades = JPanel(GridLayout(2, 2)) val pBotonsMov = JPanel(FlowLayout()) val pTancar = JPanel(FlowLayout()) val con = DriverManager.getConnection(\"jdbc:postgresql://89.36.214.106:5432/geo_ad\", \"geo_ad\", \"geo_ad\") val st = con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY) val rs = st.executeQuery(\"SELECT * FROM COMARCA ORDER BY 1\") init { defaultCloseOperation = JFrame.EXIT_ON_CLOSE setBounds(100, 100, 350, 400) setLayout(BorderLayout()) getContentPane().add(pCentre, BorderLayout.CENTER) getContentPane().add(JPanel(FlowLayout()), BorderLayout.WEST) getContentPane().add(JPanel(FlowLayout()), BorderLayout.EAST) getContentPane().add(pTancar, BorderLayout.SOUTH) pDalt.add(JLabel(\"Manteniment de COMARQUES\")) pCentre.add(pDalt) pDades.add(JLabel(\"Nom comarca\")) pDades.add(nomComarca) pDades.add(JLabel(\"Nom prov\u00edncia\")) pDades.add(nomProvincia) pCentre.add(pDades) nomComarca.setEditable(false) nomProvincia.setEditable(false) pCentre.add(JPanel(FlowLayout())) pBotonsMov.add(primer) pBotonsMov.add(anterior) pBotonsMov.add(seguent) pBotonsMov.add(ultim) pCentre.add(pBotonsMov) pTancar.add(tancar) rs.first() visComarca() primer.addActionListener { rs.first() visComarca() } anterior.addActionListener { if (!rs.isFirst()) rs.previous() visComarca() } seguent.addActionListener { if (!rs.isLast()) rs.next() visComarca() } ultim.addActionListener { rs.last() visComarca() } tancar.addActionListener{ rs.close() st.close() con.close() System.exit(0) } } fun visComarca() { nomComarca.setText(rs.getString(1)) nomProvincia.setText(rs.getString(2)) } } fun main(args: Array<String>) { EventQueue.invokeLater({ Exemple_4_41_Scroll().isVisible = true }) } Aquest \u00e9s el resultat: 6.3 - Tractament d'errors en aplicacions JDBC \u00b6 L\u2019execuci\u00f3 de sent\u00e8ncies SQL est\u00e0 sotmesa a molts de factors que poden provocar algun error. Pot passar que la connexi\u00f3 falle, que el controlador no siga l\u2019adequat, que les sent\u00e8ncies tinguen errades, que el SGBD no suporte la sent\u00e8ncia, i un llarg etc\u00e8tera de possibilitats. Nota Podeu trobar informaci\u00f3 referida als codis de SQLSTATE en la wikipedia, en aquest enlla\u00e7 . El codi SQLSTATE est\u00e0 format per cinc car\u00e0cters. Els dos primers indiquen la tipologia de l\u2019error i els tres \u00faltims el concreten. Els errors SQL es troben molt ben definits a l\u2019especificaci\u00f3 est\u00e0ndard, la qual descriu el valor de la variable anomenada SQLSTATE , que identifica l\u2019estat d\u2019una sent\u00e8ncia SQL immediatament despr\u00e9s de la seua execuci\u00f3. Quan JDBC detecta que despr\u00e9s d\u2019una execuci\u00f3 el valor d\u2019aquesta variable es correspon a un error, dispara una excepci\u00f3 de tipus SQLException la qual, a m\u00e9s de contenir un missatge clarificador, incorpora el valor del SQLSATE . Podem recuperar aquest valor amb el m\u00e8tode getSQLState() . L\u2019\u00fas de try-catch ens permetr\u00e0 capturar espec\u00edficament excepcions SQLException o derivades. Una vegada capturades, utilitzarem el codi SQLSTATE per decidir com cal actuar. Un altre m\u00e8tode molt \u00fatil \u00e9s getMessage() que torna una cadena amb l'error produ\u00eft. Pot servir perfectament per a la resta d'errors no tractats, ja que amb aquest missatge sempre donarem una pista, encara que no personalitzada com abans. Imaginem, per exemple, que en intentar connectar amb un SGBD capturem una excepci\u00f3 SQL amb el valor SQLState igual a 28000 . Si consulteu aquest codi a la p\u00e0gina que us indiquem en la nota de dalt veureu que el valor 28000 correspon a un error en l\u2019autenticaci\u00f3. En canvi, si el codi rebut haguera estat 08001 significaria que JDBC est\u00e0 trobant problemes de xarxa a l\u2019hora de connectar, ja siguen deguts a una desconnexi\u00f3 f\u00edsica, o simplement a un host o adre\u00e7a IP desconegut. Nota PostgreSQL defineix millor l'error d'autenticaci\u00f3. En el cas de PostgreSQL \u00e9s el 28P01. Per tant haur\u00edem de substituir per aquest valor en el programa posterior si volem connectar a ell. La taula d'errors de PostgreSQL la podeu trobar en aquest enlla\u00e7 No cal informar detalladament l\u2019usuari de tots i cadascun dels possibles errors, per\u00f2 s\u00ed que cal decidir quins errors requeriran un tractament espec\u00edfic i quins no. Segurament no seria mala idea, si detectem un SQLState de valor 08001 , aconsellar l\u2019usuari que abans de trucar al servei t\u00e8cnic revise les connexions de xarxa o s\u2019assegure que el SGBD es troba en marxa. D\u2019altra banda, la detecci\u00f3 precisa del SQLState ens pot tamb\u00e9 permetre realitzar accions per reconduir l\u2019error. Imaginem, per exemple, que per raons de seguretat l\u2019administrador del SGBD va canviant de contrasenya. L\u2019administrador tria una contrasenya a l\u2019atzar d\u2019entre un conjunt de tres o quatre prefixades. Per tal de no haver d\u2019estar cont\u00ednuament configurant la nostra aplicaci\u00f3 cada vegada que canvie la contrasenya, podem implementar una utilitat que accepte un conjunt de tres o quatre contrasenyes de manera que puga anar provant d\u2019una en una quan reba un error d\u2019autenticaci\u00f3. Per a la resta d'errors, podem avisar a l'usuari de l'error que s'ha produ\u00eft, o podem utilitzar una altra t\u00e8cnica, que \u00e9s utilitzar enregistradors. Els enregistradors ( loggers ) van guardant autom\u00e0ticament en un fitxer les coses que van succeint. Vegem un possible exemple on posem en pr\u00e0ctica totes les consideracions que acabem de comentar. Est\u00e0 fet sobre MySQL , ja que com hem comentat abans, PostgreSQL utilitza ara un altre codi d'error per a la contrasenya inv\u00e0lida. Tindrem 3 contrasenyes possibles per a la connexi\u00f3. Si qualsevol de les 3 \u00e9s bona, es connectar\u00e0. Sin\u00f3 indicar\u00e0 que hi ha un error en la contrasenya. Copieu el seg\u00fcent codi en un fitxer Kotlin anomenat Exemple_4_51_TractamentErrors.kt : package exemples import java.sql.Connection import java.sql.DriverManager import java.sql.SQLException fun main(args: Array<String>) { var connectat = false var con: Connection? = null println(\"tractamentErrorConnexio()\") try { val url = \"jdbc:postgresql://89.36.214.106:5432/geo_ad\" val usuari = \"geo_ad\" val contrasenyes = arrayOf(\"geo0\", \"geo1\", \"geo_ad\") for (i in 0 until contrasenyes.size) { try { con = DriverManager.getConnection(url, usuari, contrasenyes[i]) connectat = true break } catch (ex: SQLException) { if (!ex.getSQLState().equals(\"28P01\")) { // NO \u00e9s un error d'autenticaci\u00f3 throw ex } } } if (connectat) println(\"Connexi\u00f3 efectuada correctament\") else println(\"Error en la contrasenya\") } catch (ex: SQLException) { if (ex.getSQLState().equals(\"08001\")) { println( \"S'ha detectat un problema de connexi\u00f3. Reviseu els cables de xarxa i assegureu-vos que el SGBD est\u00e0 operatiu.\" + \" Si continua sense connectar, aviseu el servei t\u00e8cnic\" ) } else { println( \"S'ha produ\u00eft un error inesperat. Truqueu al servei t\u00e8cnic indicant el seg\u00fcent codi d'error SQL:\" + ex.getSQLState() ) } } catch (ex: ClassNotFoundException) { println(\"No s'ha trobat el controlador JDBC (\" + ex.message + \"). Truqueu al servei t\u00e8cnic\") } finally { try { if (con != null && !con.isClosed()) { con.close() } } catch (ex: SQLException) { throw ex } } } 6.4 - Transaccions \u00b6 Una transacci\u00f3 \u00e9s un conjunt de sent\u00e8ncies SQL d'actualitzaci\u00f3 (INSERT, DELETE, UPDATE) que o b\u00e9 s'executen totes o b\u00e9 no s'executa ninguna. La manera de confirmar les sent\u00e8ncies \u00e9s amb COMMIT , i la manera de rebutjar-les totes \u00e9s ROLLBACK (quedant l'estat com estava abans de comen\u00e7ar la transacci\u00f3). En qualsevol dels dos casos, despr\u00e9s d'executar les sent\u00e8ncies de control COMMIT o ROLLBACK , comen\u00e7ar\u00e0 una transacci\u00f3 nova. JDBC trasllada tamb\u00e9 aquest metodologia al seu API. Per defecte, les connexions JDBC consideren que cada objecte Statement \u00e9s en si mateix una transacci\u00f3. Abans de cada execuci\u00f3 es demana l\u2019inici d\u2019una transacci\u00f3 i al final, si l\u2019execuci\u00f3 t\u00e9 \u00e8xit, s\u2019envia un commit i si no t\u00e9 \u00e8xit, un rollback . Per aix\u00f2 diem que la connexi\u00f3 actua en mode autocommit . Per\u00f2 hi ha una altra manera de funcionar. Els Statements poden treballar sense automatitzar el commit despr\u00e9s de cada execuci\u00f3, canviant la connexi\u00f3 de mode amb el m\u00e8tode setAutoCommit(false) . A partir d\u2019aleshores es consideraran instruccions d\u2019una mateixa transacci\u00f3 totes les sent\u00e8ncies executades entre dues cridades als m\u00e8todes commit o rollback (equivalents JDBC de les instruccions COMMIT i ROLLBACK de SQL). A continuaci\u00f3 tenim un programa en el qual fem una s\u00e8rie de canvis (una modificaci\u00f3 de files i un esborrat) per\u00f2 despr\u00e9s fem un rollback, i per tant no s'haur\u00e0 fet cap de les actualitzacions. \u00c9s sobre la Base de Dades de SQLite Empleats,sqlite , que nom\u00e9s tenia la taula EMPLEAT. Per a mostrar que estem fent els canvis, per\u00f2 que despr\u00e9s ls desfem amb rollback , mostrem un resum en el qual senzillament indiquem el n\u00famero d'empleat i el total dels sous. Pr\u00e8viament ens guardem el estat que tenia l' autocommit , i despr\u00e9s el desactivem. Quan finalitza tot el proc\u00e9s posem autocommit com estava en un principi. Copieu el seg\u00fcent codi en un fitxer Kotlin anomenat Exemple_4_61_Transaccions.kt : package exemples import java.sql.DriverManager import java.sql.Connection fun main(args: Array<String>) { val con = DriverManager.getConnection(\"jdbc:sqlite:Empleats.sqlite\") resumEmpleats(con) // estat inicial val autocommit = con.getAutoCommit() con.setAutoCommit(false) val st = con.createStatement() st.executeUpdate(\"UPDATE EMPLEAT SET sou = sou * 1.05\") st.executeUpdate(\"DELETE FROM EMPLEAT WHERE depart=10\") resumEmpleats(con) // s'han modificat els sous i s'han esborrat dos empleats con.rollback() // desfem els canvis resumEmpleats(con) // hem tornat a l'estat inicial: // no s'ha fet ni l'actualitzaci\u00f3 de sous ni l'esborrat d'empleats con.setAutoCommit(autocommit) con.close() } fun resumEmpleats(c: Connection) { // En el resum traurem el n\u00famero d'empleats i el total de sous val st = c.createStatement() val rs = st.executeQuery(\"SELECT COUNT(*), SUM(sou) FROM EMPLEAT\") rs.next() println(\"Actualment hi ha \" + rs.getInt(1) + \" empleats que cobren un total de \" + rs.getDouble(2) + \" \u20ac\") rs.close() st.close() } La major part de SGBD permeten utilitzar transaccions expl\u00edcites amb qualsevol instrucci\u00f3 SQL, fins i tot alguns SGBD tamb\u00e9 en sent\u00e8ncies DDL ( data definition language ) com CREATE TABLE, etc . Les sent\u00e8ncies de definici\u00f3 modifiquen directament l\u2019estructura de les dades i, per tant, cal anar molt en compte perqu\u00e8 poden provocar danys importants, p\u00e8rdues de dades existents, etc. Per\u00f2 hi ha alguns SGBD com Oracle que no suporten la revocaci\u00f3 de sent\u00e8ncies DDL i en cas d\u2019executar rollback , obtindrem un error indicant que les sent\u00e8ncies DDL no es poden revocar. 6.5 - Millora de rendiment \u00b6 Un altre aspecte important que mesura la qualitat de les aplicacions \u00e9s l\u2019efici\u00e8ncia amb la qual s\u2019aconsegueix comunicar amb el SGBD. Per optimitzar la connexi\u00f3 \u00e9s important recon\u00e8ixer quins processos poden actuar de coll d\u2019ampolla. En primer lloc, analitzarem la petici\u00f3 de connexi\u00f3 a un SGBD perqu\u00e8 es tracta d\u2019un proc\u00e9s cost\u00f3s per\u00f2 inevitable que cal considerar. En segon lloc, estudiarem les sent\u00e8ncies predefinides, perqu\u00e8 el seu \u00fas facilita la creaci\u00f3 de dades clau i \u00edndexs temporals de manera que siga possible anticipar-se a la demanda o disposar de les dades de forma molt m\u00e9s r\u00e0pida. Temps de vida d'una connexi\u00f3 L\u2019establiment d\u2019una connexi\u00f3 \u00e9s un procediment molt lent, tant a la part client com a la part servidor. A la part client, DriverManager ha de descobrir el controlador correcte d\u2019entre tots els que haja de gestionar. La majoria de vegades les aplicacions treballaran nom\u00e9s amb un \u00fanic controlador, per\u00f2 cal tenir en compte que DriverManager no coneix a priori quina URL de connexi\u00f3 correspon a cada controlador, i per saber-ho envia una petici\u00f3 de connexi\u00f3 a cada controlador que tinga registrat, el controlador que no li retorna error ser\u00e0 el correcte. A la banda servidor, es crear\u00e0 un context espec\u00edfic i s\u2019habilitaran un conjunt de recursos per cada client connectat. \u00c9s a dir, que durant la petici\u00f3 de connexi\u00f3 el SGDB ha de gastar un temps considerable abans de deixar operativa la comunicaci\u00f3 client-servidor. Aquesta elevat cost de temps concentrat en el moment de la petici\u00f3 de connexi\u00f3 fa que ens plantegem si val la pena obrir i tancar la connexi\u00f3 cada vegada que ens toque executar una sent\u00e8ncia SQL, o obrir una connexi\u00f3 al principi de l'aplicaci\u00f3 que tancar\u00edem en finalitzar. Lamentablement no hi ha una \u00fanica resposta, sin\u00f3 que dep\u00e8n de la freq\u00fc\u00e8ncia d\u2019\u00fas de la connexi\u00f3 i el n\u00famero de connexions contra el mateix SGBD. Com en tot, es tracta de trobar el punt d\u2019equilibri. Si el n\u00famero de clients, i per tant de connexions, \u00e9s baix i la freq\u00fc\u00e8ncia d\u2019\u00fas \u00e9s alta, ser\u00e0 preferible mantenir les connexions obertes molt de temps. Per contra, si el n\u00famero de connexions \u00e9s molt alt i la freq\u00fc\u00e8ncia d'\u00fas baixa, el que ser\u00e0 preferible ser\u00e0 obrir i tancar la connexi\u00f3 cada vegada que es necessite. I tamb\u00e9 hi haur\u00e0 una multitud de casos en qu\u00e8 la soluci\u00f3 consistir\u00e0 a mantenir les connexions obertes per\u00f2 no permanentment. Es pot donar un temps de vida a cada connexi\u00f3, o b\u00e9 tancar-les despr\u00e9s de restar inactiva una quantitat determinada de temps, o es pot fer servir el criteri de mantenir un n\u00famero m\u00e0xim de connexions obertes, tancant les m\u00e9s antigues o les m\u00e9s inactives quan se sobrepasse el l\u00edmit. Sent\u00e8ncies predefinides JDBC disposa d\u2019un objecte derivat del Statement que s\u2019anomena PreparedStatement ., a la qual se li passa la sent\u00e8ncia SQL en el moment de crear-lo, no en el moment d'executar la sent\u00e8ncia (com passava amb Statement ). I a m\u00e9s aquesta sent\u00e8ncia pot admetre par\u00e0metres, cosa que ens pot anar molt b\u00e9 en determinades ocasions. Siga com siga, PreparedStatement presenta avantatges sobre el seu antecessor Statement quan ens toque treballar amb sent\u00e8ncies que s'hagen d'executar diverses vegades. La ra\u00f3 \u00e9s que qualsevol sent\u00e8ncia SQL, quan s\u2019envia al SGBD ser\u00e0 compilada abans de ser executada. Utilitzant un objecte Statement , cada vegada que fem una execuci\u00f3 d\u2019una sent\u00e8ncia, ja siga via executeUpdate o b\u00e9 via executeQuery , el SGBD la compilar\u00e0, ja que li arribar\u00e0 en forma de cadena de car\u00e0cters. En canvi, al PreparedStament la sent\u00e8ncia mai varia i per tant es pot compilar i guardar dins del mateix objecte, de manera que les seg\u00fcents vegades que s\u2019execute no caldr\u00e0 compilar-la. Aix\u00f2 reduir\u00e0 sensiblement el temps d\u2019execuci\u00f3. En alguns sistemes gestors, a m\u00e9s, fer servir PreparedStatements pot arribar a suposar m\u00e9s avantatges, ja que utilitzen la seq\u00fc\u00e8ncia de bytes de la sent\u00e8ncia per detectar si es tracta d\u2019una sent\u00e8ncia nova o ja s\u2019ha servit amb anterioritat. D\u2019aquesta manera es propicia que el sistema guarde les respostes en la mem\u00f2ria cach\u00e9, de manera que es puguen lliurar de forma m\u00e9s r\u00e0pida. En el moment de programar, la principal difer\u00e8ncia dels objectes PreparedStatement en relaci\u00f3 als Statement , \u00e9s que en els \u00faltims la sent\u00e8ncia es passa com a par\u00e0metre en el moment d'executar-lo, mentre que en els primers se'ls passa la sent\u00e8ncia SQL predefinida en el moment de crear-lo (no d'executar-lo). Com que la sent\u00e8ncia queda predefinida, ni els m\u00e8todes executeUpdate ni executeQuery requeriran cap par\u00e0metre. \u00c9s a dir, justet al rev\u00e8s que en el Statement . Posem un exemple, en el qual demanem per teclat el nom d'una comarca i una altura, per a traure els pobles de la comarca introdu\u00efda que estan a una altura superior a l'altura introdu\u00efda. Copieu el seg\u00fcent codi en un fitxer Kotlin anomenat Exemple_4_71_Statement.kt : package exemples import java.sql.DriverManager import java.util.Scanner fun main(args: Array<String>) { val con = DriverManager.getConnection(\"jdbc:postgresql://89.36.214.106:5432/geo_ad\", \"geo_ad\", \"geo_ad\") println(\"Introdueix una comarca:\") val com = Scanner(System.`in`).nextLine() println(\"Introdueix una altura:\") val alt = Scanner(System.`in`).nextInt() val st = con.createStatement() // La sent\u00e8ncia no va en el moment de la creaci\u00f3 sin\u00f3 en el d'execuci\u00f3 val rs = st.executeQuery(\"SELECT nom,altura FROM POBLACIO WHERE nom_c='\" + com + \"' AND altura>\" + alt) while (rs.next()) { println(rs.getString(1) + \" (\" +rs.getInt(2) + \" m.)\") } st.close() con.close() } Observeu com per al cas del nom de la comarca, que \u00e9s un String (o millor dit un Varchar), en la sent\u00e8ncia SQL hem de posar una cometa simple (') abans i despr\u00e9s del valor de la comarca, ja que \u00e9s aix\u00ed com s'expressen els Varchar. Resulta un poc inc\u00f2mode. Si utilitzem PreparedStatement , nom\u00e9s haurem de canviar les l\u00ednies 14 i 15. Copieu el seg\u00fcent codi en un fitxer Kotlin anomenat Exemple_4_72_PreparedStatement.kt , i observeu com nom\u00e9s han canviat les l\u00ednies 14 i 15: package exemples import java.sql.DriverManager import java.util.Scanner fun main(args: Array<String>) { val con = DriverManager.getConnection(\"jdbc:postgresql://89.36.214.106:5432/geo_ad\", \"geo_ad\", \"geo_ad\") println(\"Introdueix una comarca:\") val com = Scanner(System.`in`).nextLine() println(\"Introdueix una altura:\") val alt = Scanner(System.`in`).nextInt() val st = con.prepareStatement(\"SELECT nom,altura FROM POBLACIO WHERE nom_c='\" + com + \"' AND altura>\" + alt) val rs = st.executeQuery() // La sent\u00e8ncia no va en el moment de l'execuci\u00f3 sin\u00f3 en el de creaci\u00f3 while (rs.next()) { println(rs.getString(1) + \" (\" +rs.getInt(2) + \" m.)\") } st.close() con.close() } Per\u00f2 anem un pas m\u00e9s enll\u00e0 i anem a utilitzar par\u00e0metres. La utilitzaci\u00f3 de par\u00e0metres, a banda de la comoditat, en pot anar molt b\u00e9 per a previndre errors. Observeu com en els dos exemples anteriors ten\u00edem un problema si el nom de la comarca cont\u00e9 una cometa simple (') com \u00e9s en el cas per exemple de la Vall d'Albaida . Si intentem posar aquesta comarca ens saltar\u00e0 un error, i \u00e9s perqu\u00e8 interpretar\u00e0 la cometa com el final de la cadena Varchar, i no sabr\u00e0 qu\u00e8 \u00e9s Albaida SELECT nom,altura FROM POBLACIO WHERE nom_c='Vall d'Albaida' AND altura=500 La manera de solucionar-ho seria escapar la cometa, o doblar-la (vull dir 2 cometes simples, no doble cometa). Per\u00f2 tamb\u00e9 ens pot anar molt b\u00e9 i molt c\u00f2mode utilitzar par\u00e0metres, com veurem ara. Els par\u00e0metres de la sent\u00e8ncia es marcaran amb el s\u00edmbol d\u2019interrogant (?) i s\u2019identificaran per la posici\u00f3 que ocupen a la sent\u00e8ncia, comen\u00e7ant a comptar des de l\u2019esquerra i a partir del n\u00famero 1. El valor dels par\u00e0metres s\u2019assignar\u00e0 fent servir el m\u00e8tode espec\u00edfic, d\u2019acord amb el tipus de dades a assignar. El nom d'aquestos m\u00e8todes comen\u00e7ar\u00e0 per set i continuar\u00e0 amb el nom del tipus de dades (exemples: setString() , setInt() , setLong() , setBoolean() \u2026). Tots aquestos m\u00e8todes segueixen la mateixa sintaxi: setXXXX(<posicioALaSentenciaSQL>, <valor>) Veiem com quedaria el nostre exemple. Copieu el seg\u00fcent codi en un fitxer Kotlin anomenat Exemple_4_73_PreparedStatement_ambParametres.kt : package exemples import java.sql.DriverManager import java.util.Scanner fun main(args: Array<String>) { val con = DriverManager.getConnection(\"jdbc:postgresql://89.36.214.106:5432/geo_ad\", \"geo_ad\", \"geo_ad\") println(\"Introdueix una comarca:\") val com = Scanner(System.`in`).nextLine() println(\"Introdueix una altura:\") val alt = Scanner(System.`in`).nextInt() val st = con.prepareStatement(\"SELECT nom,altura FROM POBLACIO WHERE nom_c=? AND altura>?\") st.setString(1,com) // Abans d'executar-la s'han d'iniciar els par\u00e0metres st.setInt(2,alt) val rs = st.executeQuery() // La sent\u00e8ncia no va en el moment de l'execuci\u00f3 sin\u00f3 en el de creaci\u00f3 while (rs.next()) { println(rs.getString(1) + \" (\" +rs.getInt(2) + \" m.)\") } st.close() con.close() } Mireu com \u00e9s m\u00e9s c\u00f2mode, perqu\u00e8 en el moment de definir la sent\u00e8ncia (quan creem el PreparedStatement) per a el string no ens hem preocupat de posar la cometa. Ni tampoc en el moment de definir el par\u00e0metre en la l\u00ednia seg\u00fcent. I a m\u00e9s ara no fallar\u00e0 quan posem la comarca Vall d'Albaida Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement CompartirIgual 2.5","title":"6 - JDBC avan\u00e7at"},{"location":"6__jdbc_avanat/#6-jdbc-avancat","text":"JDBC disposa d\u2019una alta funcionalitat i estructures que poden ajudar-nos a incrementar la qualitat de les aplicacions que constru\u00efm. La primera \u00e9s poder accedir no a les dades, sin\u00f3 a les estructures de les dades, \u00e9s a dir, l'estructura de les taules o de les consultes que fem: noms de les columnes, tipus, etc. En definitiva \u00e9s accedir a les Metadades. Tamb\u00e9 seria convenient construir aplicacions flexibles, robustes i eficients. Necessitarem, doncs, un bon tractament d\u2019errors que trasllade quan fa\u00e7a falta la informaci\u00f3 adequada a l\u2019usuari o reconduint el flux de l\u2019execuci\u00f3 cap a processos que interpreten i compensen els errors. L\u2019efici\u00e8ncia \u00e9s tamb\u00e9 una caracter\u00edstica important de la qualitat. En general, els Sistemes Gestors de Bases de Dades disposen de mecanismes autom\u00e0tics per potenciar l\u2019efici\u00e8ncia de les peticions, com ara l\u2019\u00fas de mem\u00f2ria cach\u00e9 d\u2019acc\u00e9s r\u00e0pid, la creaci\u00f3 d\u2019\u00edndexs autom\u00e0tics, etc. Aquestos automatismes responen a determinats patrons a l\u2019hora de fer les peticions. Per aix\u00f2 JDBC preveu altres formes, diferents a les estudiades fins ara, per realitzar peticions que milloren el rendiment.","title":"6 - JDBC avan\u00e7at"},{"location":"6__jdbc_avanat/#61-acces-a-les-meta-dades","text":"Normalment quan accedim a una Base de Dades des d'un programa Java, coneixerem l'estructura d'aquesta Base de Dades, \u00e9s a dir, les taules que t\u00e9 i cada taula quins camps i de quin tipus s\u00f3n. I fins i tot les claus externes entre les taules. Per\u00f2 podria passar que no conegu\u00e9rem aquesta estructura. Aix\u00f2 no hauria de ser un problema per accedir a la Base de Dades, ja que aquesta \u00e9s autodescriptiva, \u00e9s a dir, que hem de poder consultar a la Base de Dades per a que ens diga la seua estructura. L'objecte que ens d\u00f3na aquesta informaci\u00f3 \u00e9s el DatabaseMetaData . Disposa de molts m\u00e8todes que ens proporcionen gran quantitat d'informaci\u00f3. I tamb\u00e9 ens d\u00f3na informaci\u00f3 un altre objecte, ResultSetMetaData , que obtindr\u00e0 la informaci\u00f3 a partir d'un ResultSet . Veurem els dos per separat. DatabaseMetaData \u00c9s l'adequat quan volem veure les taules i vistes que tenim en la Base de Dades, aix\u00ed com l'estructura de cadascuna d'elles. Mirem primer els m\u00e8todes m\u00e9s interessants que t\u00e9: Valor tornat Nom del m\u00e8tode Descripci\u00f3 String getDatabaseProductName() Torna el nom del SGBD String getDriverName() Torna el driver JDBC utilitzat String getURL() Torna la URL de la connexi\u00f3 String getUserName() Torna el nom de l'usuari que s'ha connectat ResultSet getTables(cataleg, esquema, nom, tipus) Torna informaci\u00f3 de totes les taules que coincideixen amb els patrons o criteris. Si posem null a tots els par\u00e0metres ens tornar\u00e0 totes les taules i vistes ResultSet getColumns(cataleg, esquema, nom, nom_colu) Torna informaci\u00f3 de les columnes de la taula especificada en el tercer par\u00e0metre (que est\u00e0 en el cat\u00e0leg i en l'esquema, si els posem). El quart par\u00e0metre servir\u00e0 per a seleccionar les columnes que coincidesquen amb el patr\u00f3 (null per a totes) ResultSet getPrimaryKeys(cataleg, esquema, taula) Torna la llista de camps que formen la clau principal ResultSet getImportedKeys(cataleg, esquema, taula) Torna una llista amb les claus externes definides en aquesta taula ResultSet getExportedKeys(cataleg, esquema, taula) Torna una llista amb les claus externes que apunten a aquesta taula Per poder comprovar tot l'anterior, farem un programa que ens done informaci\u00f3 de la Base de Dades, una relaci\u00f3 de les taules i vistes que t\u00e9. Posteriorment acceptar\u00e0 un n\u00famero, i traur\u00e0 la informaci\u00f3 de la taula corresponent amb aquest format: columnes, tipus, clau principal, claus externes. Copieu elseg\u00fcent codi en un fitxer Kotlin anomenat Exemple_4_31_MetaData.kt : package exemples import java.sql.DriverManager import java.io.BufferedReader import java.io.InputStreamReader fun main(args: Array<String>) { val con = DriverManager.getConnection (\"jdbc:postgresql://89.36.214.106:5432/geo_ad\", \"geo_ad\", \"geo_ad\") val dbmd = con.getMetaData () println(\"Informaci\u00f3 general\") println(\"------------------\") println(\"SGBD \" + dbmd.getDatabaseProductName()) println(\"Driver \" + dbmd.getDriverName()) println(\"URL \" + dbmd.getURL()) println(\"Usuari \" + dbmd.getUserName()) println() println(\"Llistat de taules\") println(String.format(\"%-6s %-7s %-7s %-10s %-10s\", \"N\u00famero\", \"Cat\u00e0leg\", \"Esquema\", \"Nom\", \"Tipus\")) println(\"---------------------------------------------\") val ll = dbmd.getTables(null, \"public\", null, null) var compt = 1 val taules = ArrayList<String>() while (ll.next()) { println(String.format(\"%-6d %-7s %-7s %-10s %-10s\",(compt++),ll.getString(1),ll.getString(2),ll.getString(3),ll.getString(4))) taules.add(ll.getString(3)) } println() println(\"Introdueix un n\u00famero per veure l'estructura de la taula (0 per acabar) \") val ent = BufferedReader(InputStreamReader (System.`in`)) var opcio = Integer.parseInt(ent.readLine()) while (opcio != 0) { if (opcio < compt && opcio > 0) { val taula = dbmd.getTables (null, \"public\", taules.get(opcio-1), null) if (taula.next()) { if (taula.getString(4).equals(\"TABLE\")) { val rs = dbmd.getColumns (null, \"public\", taules.get(opcio-1), null) println(\"Estructura de la taula \" + taules.get(opcio - 1)) println(\"----------------------------\") while (rs.next()) println(rs.getString(4) + \" (\" + rs.getString(6) + \")\") println(\"----------------------------\") val rs2 = dbmd.getPrimaryKeys(null, \"public\", taules.get(opcio - 1)) print(\"Clau principal \") while (rs2.next()) print(rs2.getString(4) + \" \") println() val rs3 = dbmd.getImportedKeys(null, \"public\", taules.get(opcio - 1)) println(\"Claus externes \") while (rs3.next()) { println(rs3.getString(8) + \" apunta a \" + rs3.getString(3)) } rs.close() rs2.close() rs3.close() } } taula.close() } println() println(\"Introdueix un n\u00famero per veure l'estructura de la taula (0 per acabar) \") opcio = Integer.parseInt(ent.readLine()) } ll.close() con.close() } ResultSetMetaData Una vegada executada una sent\u00e8ncia SELECT de SQL que ja tenim el resultat en un ResultSet, podem accedir tamb\u00e9 a meta dades d'aquest ResultSet, obtenint per exemple el n\u00famero de columnes, o el tipus de les columnes. Ho obtenim per mig del ResulSetMetaData . Nom\u00e9s veurem 3 m\u00e8todes Valor tornat Nom del m\u00e8tode Descripci\u00f3 int getColumnCount() Torna el n\u00famero de columnes del ResultSet String getColumnName(index) Torna el nom de la columna (la primera columna \u00e9s la 1) String getColumnTypeName(index) Torna el tipus de la columna El seg\u00fcent exemple \u00e9s una modificaci\u00f3 del programa anterior, on ara traurem tot el contingut d'una taula per mig de la sent\u00e8ncia SELECT * FROM taula . Intentarem donar-li un aspecte tabular, per\u00f2 sense patir molt per l'aspecte. Copieu el seg\u00fcent codi en un fitxer Kotlin anomenat Exemple_4_32_ResultSetMetaData.kt : package exemples import java.sql.DriverManager import java.io.BufferedReader import java.io.InputStreamReader fun main(args: Array<String>) { val con = DriverManager.getConnection(\"jdbc:postgresql://89.36.214.106:5432/geo_ad\", \"geo_ad\", \"geo_ad\") val dbmd = con.getMetaData() println(\"Llistat de taules:\") println(String.format(\"%-6s %-7s %-7s %-10s %-10s\", \"N\u00famero\", \"Cat\u00e0leg\", \"Esquema\", \"Nom\", \"Tipus\")) println(\"---------------------------------------------\") val ll = dbmd.getTables(null, \"public\", null, null) var compt = 1 val taules = ArrayList<String>() while (ll.next()) { println(String.format(\"%-6d %-7s %-7s %-10s %-10s\",(compt++),ll.getString(1),ll.getString(2), ll.getString(3),ll.getString(4))) taules.add(ll.getString(3)) } println() println(\"Introdueix un n\u00famero per veure el contingut de la taula (0 per acabar): \") val ent = BufferedReader(InputStreamReader(System.`in`)) var opcio = Integer.parseInt(ent.readLine()) while (opcio != 0) { if (opcio < compt && opcio > 0) { val taula = dbmd.getTables(null, \"public\", taules.get(opcio - 1), null) if (taula.next()) { if (taula.getString(4).equals(\"TABLE\")) { val rs = con.createStatement().executeQuery(\"SELECT * FROM \" + taules.get(opcio - 1) + \" ORDER BY 1\") println(\"Contingut de la taula \" + taules.get(opcio - 1)) println(\"----------------------------\") val rsmd = rs.getMetaData() for (i in 1..rsmd.getColumnCount()) print(String.format(\"%-20.20s\", rsmd.getColumnName(i))) println() println(\"------------------------------------------\") while (rs.next()) { for (i in 1..rsmd.getColumnCount()) print(String.format(\"%-20.20s \", rs.getString(i))) println() } rs.close() } } taula.close() } println() println(\"Introdueix un n\u00famero per veure el contingut de la taula (0 per acabar): \") opcio = Integer.parseInt(ent.readLine()) } ll.close() con.close() }","title":"6.1 - Acc\u00e9s a les Meta Dades"},{"location":"6__jdbc_avanat/#62-resultsets-que-poden-avancar-cap-avant-i-cap-arrere","text":"Fins el moment, tots els ResultSet que hem creat podien avan\u00e7ar \u00fanicament cap avant, fent un recorregut seq\u00fcencial de les dades. Inicialment el punter que apunta a l'estructura est\u00e0 situat abans de la primera fila En fer next() se situa a la seg\u00fcent fila (la primera vegada se situa en la primera fila) Quan estiguem situats en l'\u00faltima fima, si fem next() se situara despr\u00e9s de l'\u00faltima, i ho indicar\u00e0 tornant false Per\u00f2 aquesta manera de funcionar, que es diu TYPE_FORWARD_ONLY i que \u00e9s l'opci\u00f3 per defecte per a obrir un ResultSet, no \u00e9s l'\u00fanica. Aquestos s\u00f3n els tipus de ResultSet que hi ha: TYPE_FORWARD_ONLY : \u00e9s el tipus utilitzat fins el moment, i \u00e9s el tipus per defecte. El ResultSet nom\u00e9s pot avan\u00e7ar cap avant. TYPE_SCROLL_INSENSITIVE : El ResultSet pot avan\u00e7ar cap avant i cap arrere, fins i tot pot anar a una posici\u00f3 absoluta (directament, sense passar per les anteriors). El ResultSet no \u00e9s sensible als canvis fets en les dades que han proporcionat aquest resultat, \u00e9s a dir, ens mostra les dades que hi havia en el moment d'executar la consulta, sense poder mostrar possibles canvis posteriors. TYPE_SCROLL_SENSITIVE : Igual que l'anterior en quant al moviment. Per\u00f2 ara s\u00ed que \u00e9s capa\u00e7 de mostrar possibles canvies fets en les dades originals posteriors al moment de l'execuci\u00f3 de la consulta, mentre el ResultSet estiga obert. I per una altra banda el ResultSet pot tenir la possibilitat d' actualitzar les dades originals. Des d'aquest punt de vista hi ha 2 possibles tipus: CONCUR_READ_ONLY : El ResultSet nom\u00e9s \u00e9s de lectura i no es pot actualitzar CONCUR_UPDATABLE : El ResultSet es pot actualitzar (i els canvis es reflectiran en les dades originals) utilitzant el mateix ResultSet L'opci\u00f3 per defecte \u00e9s CONCUR_READ_ONLY Realment on declararem els tipus \u00e9s en la creaci\u00f3 del STATEMENT a partir del qual crearem la sent\u00e8ncia que omplir\u00e0 el ResultSet . \u00c9s l\u00f2gic, ja que aquestes maneres de funcionar s'han de preparar abans d'executar la sent\u00e8ncia. Fins ara no hav\u00edem posat par\u00e0metres en la creaci\u00f3 del Statement , cosa que fa que es cree amb les opcions per defecte. Si volem altres opcions: val st =con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY) val st =con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE,ResultSet.CONCUR_UPDATABLE) La primera q\u00fcesti\u00f3 que hem de comentar \u00e9s que el SGBD ha de ser capa\u00e7 de suportar els tipus que no s\u00f3n per defecte, i no sempre \u00e9s aix\u00ed. Mentre que PostgreSQL , Oracle i MySQL s\u00ed que s\u00f3n capa\u00e7os de suportar tots els tipus anteriors, SQLite no ho pot fer i tan sols suporta TYPE_FORWARD_ONLY i CONCUR_READ_ONLY , com era d'esperar. Deixant de banda la possibilitat de reflectir els possibles canvis de les dades originals ( SENSITIVE ), i de poder actualitzar-les ( CONCUR_UPDATABLE ), anem a estudiar els possibles moviments dins del ResultSet . next : Avan\u00e7a una fila cap avant. Torna true si s'ha pogut posicionar, i false si no s'ha pogut posicionar, per estar despr\u00e9s de l'\u00faltima fila. previous : Avan\u00e7a una fila cap arrere. Torna true si s'ha pogut posicionar, i false si no s'ha pogut posicionar, per estar abans de la primera fila. first : Se situa en la primera fila. Torna true si s'ha pogut posicionar, i false si no s'ha pogut posicionar, per no contenir el ResultSet cap fila. last: : Se situa en l'\u00faltima fila. Torna true si s'ha pogut posicionar, i false si no s'ha pogut posicionar, per no contenir el ResultSet cap fila. beforeFirst : Se situa al principi del RecordSet, abans de la primera fila. Si no hi havia cap fila, no fa res. afterLast : Se situa al final del RecordSet, despr\u00e9s de l'\u00faltima fila. Si no hi havia cap fila, no fa res. relative(int files ) : Meneja el cursor respecte de la posici\u00f3 actual, tantes files com s'indica en el par\u00e0metre (si el par\u00e0metre \u00e9s negatiu, anir\u00e0 cap arrere). absolute(int fila ) : Situa el cursor en la fila especificada en el par\u00e0metre (1 \u00e9s la primera) El seg\u00fcent exemple es practica anar a la primera, a l'anterior, a la seg\u00fcent i a l'\u00faltima fila. Copieu el seg\u00fcent codi en un fitxer Kotlin anomenat Exemple_4_41_Scroll.kt : package exemples import javax.swing.JFrame import javax.swing.JLabel import javax.swing.JTextField import javax.swing.JButton import javax.swing.JPanel import java.awt.FlowLayout import java.awt.GridLayout import java.awt.BorderLayout import java.awt.EventQueue import java.sql.DriverManager import java.sql.ResultSet class Exemple_4_41_Scroll : JFrame() { val nomComarca = JTextField() val nomProvincia = JTextField() val primer = JButton(\"<<\") val anterior = JButton(\"<\") val seguent = JButton(\">\") val ultim = JButton(\">>\") val tancar = JButton(\"Tancar\") val pDalt = JPanel(FlowLayout()) val pCentre = JPanel(GridLayout(8, 0)) val pDades = JPanel(GridLayout(2, 2)) val pBotonsMov = JPanel(FlowLayout()) val pTancar = JPanel(FlowLayout()) val con = DriverManager.getConnection(\"jdbc:postgresql://89.36.214.106:5432/geo_ad\", \"geo_ad\", \"geo_ad\") val st = con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY) val rs = st.executeQuery(\"SELECT * FROM COMARCA ORDER BY 1\") init { defaultCloseOperation = JFrame.EXIT_ON_CLOSE setBounds(100, 100, 350, 400) setLayout(BorderLayout()) getContentPane().add(pCentre, BorderLayout.CENTER) getContentPane().add(JPanel(FlowLayout()), BorderLayout.WEST) getContentPane().add(JPanel(FlowLayout()), BorderLayout.EAST) getContentPane().add(pTancar, BorderLayout.SOUTH) pDalt.add(JLabel(\"Manteniment de COMARQUES\")) pCentre.add(pDalt) pDades.add(JLabel(\"Nom comarca\")) pDades.add(nomComarca) pDades.add(JLabel(\"Nom prov\u00edncia\")) pDades.add(nomProvincia) pCentre.add(pDades) nomComarca.setEditable(false) nomProvincia.setEditable(false) pCentre.add(JPanel(FlowLayout())) pBotonsMov.add(primer) pBotonsMov.add(anterior) pBotonsMov.add(seguent) pBotonsMov.add(ultim) pCentre.add(pBotonsMov) pTancar.add(tancar) rs.first() visComarca() primer.addActionListener { rs.first() visComarca() } anterior.addActionListener { if (!rs.isFirst()) rs.previous() visComarca() } seguent.addActionListener { if (!rs.isLast()) rs.next() visComarca() } ultim.addActionListener { rs.last() visComarca() } tancar.addActionListener{ rs.close() st.close() con.close() System.exit(0) } } fun visComarca() { nomComarca.setText(rs.getString(1)) nomProvincia.setText(rs.getString(2)) } } fun main(args: Array<String>) { EventQueue.invokeLater({ Exemple_4_41_Scroll().isVisible = true }) } Aquest \u00e9s el resultat:","title":"6.2 - ResultSets que poden avan\u00e7ar cap avant i cap arrere"},{"location":"6__jdbc_avanat/#63-tractament-derrors-en-aplicacions-jdbc","text":"L\u2019execuci\u00f3 de sent\u00e8ncies SQL est\u00e0 sotmesa a molts de factors que poden provocar algun error. Pot passar que la connexi\u00f3 falle, que el controlador no siga l\u2019adequat, que les sent\u00e8ncies tinguen errades, que el SGBD no suporte la sent\u00e8ncia, i un llarg etc\u00e8tera de possibilitats. Nota Podeu trobar informaci\u00f3 referida als codis de SQLSTATE en la wikipedia, en aquest enlla\u00e7 . El codi SQLSTATE est\u00e0 format per cinc car\u00e0cters. Els dos primers indiquen la tipologia de l\u2019error i els tres \u00faltims el concreten. Els errors SQL es troben molt ben definits a l\u2019especificaci\u00f3 est\u00e0ndard, la qual descriu el valor de la variable anomenada SQLSTATE , que identifica l\u2019estat d\u2019una sent\u00e8ncia SQL immediatament despr\u00e9s de la seua execuci\u00f3. Quan JDBC detecta que despr\u00e9s d\u2019una execuci\u00f3 el valor d\u2019aquesta variable es correspon a un error, dispara una excepci\u00f3 de tipus SQLException la qual, a m\u00e9s de contenir un missatge clarificador, incorpora el valor del SQLSATE . Podem recuperar aquest valor amb el m\u00e8tode getSQLState() . L\u2019\u00fas de try-catch ens permetr\u00e0 capturar espec\u00edficament excepcions SQLException o derivades. Una vegada capturades, utilitzarem el codi SQLSTATE per decidir com cal actuar. Un altre m\u00e8tode molt \u00fatil \u00e9s getMessage() que torna una cadena amb l'error produ\u00eft. Pot servir perfectament per a la resta d'errors no tractats, ja que amb aquest missatge sempre donarem una pista, encara que no personalitzada com abans. Imaginem, per exemple, que en intentar connectar amb un SGBD capturem una excepci\u00f3 SQL amb el valor SQLState igual a 28000 . Si consulteu aquest codi a la p\u00e0gina que us indiquem en la nota de dalt veureu que el valor 28000 correspon a un error en l\u2019autenticaci\u00f3. En canvi, si el codi rebut haguera estat 08001 significaria que JDBC est\u00e0 trobant problemes de xarxa a l\u2019hora de connectar, ja siguen deguts a una desconnexi\u00f3 f\u00edsica, o simplement a un host o adre\u00e7a IP desconegut. Nota PostgreSQL defineix millor l'error d'autenticaci\u00f3. En el cas de PostgreSQL \u00e9s el 28P01. Per tant haur\u00edem de substituir per aquest valor en el programa posterior si volem connectar a ell. La taula d'errors de PostgreSQL la podeu trobar en aquest enlla\u00e7 No cal informar detalladament l\u2019usuari de tots i cadascun dels possibles errors, per\u00f2 s\u00ed que cal decidir quins errors requeriran un tractament espec\u00edfic i quins no. Segurament no seria mala idea, si detectem un SQLState de valor 08001 , aconsellar l\u2019usuari que abans de trucar al servei t\u00e8cnic revise les connexions de xarxa o s\u2019assegure que el SGBD es troba en marxa. D\u2019altra banda, la detecci\u00f3 precisa del SQLState ens pot tamb\u00e9 permetre realitzar accions per reconduir l\u2019error. Imaginem, per exemple, que per raons de seguretat l\u2019administrador del SGBD va canviant de contrasenya. L\u2019administrador tria una contrasenya a l\u2019atzar d\u2019entre un conjunt de tres o quatre prefixades. Per tal de no haver d\u2019estar cont\u00ednuament configurant la nostra aplicaci\u00f3 cada vegada que canvie la contrasenya, podem implementar una utilitat que accepte un conjunt de tres o quatre contrasenyes de manera que puga anar provant d\u2019una en una quan reba un error d\u2019autenticaci\u00f3. Per a la resta d'errors, podem avisar a l'usuari de l'error que s'ha produ\u00eft, o podem utilitzar una altra t\u00e8cnica, que \u00e9s utilitzar enregistradors. Els enregistradors ( loggers ) van guardant autom\u00e0ticament en un fitxer les coses que van succeint. Vegem un possible exemple on posem en pr\u00e0ctica totes les consideracions que acabem de comentar. Est\u00e0 fet sobre MySQL , ja que com hem comentat abans, PostgreSQL utilitza ara un altre codi d'error per a la contrasenya inv\u00e0lida. Tindrem 3 contrasenyes possibles per a la connexi\u00f3. Si qualsevol de les 3 \u00e9s bona, es connectar\u00e0. Sin\u00f3 indicar\u00e0 que hi ha un error en la contrasenya. Copieu el seg\u00fcent codi en un fitxer Kotlin anomenat Exemple_4_51_TractamentErrors.kt : package exemples import java.sql.Connection import java.sql.DriverManager import java.sql.SQLException fun main(args: Array<String>) { var connectat = false var con: Connection? = null println(\"tractamentErrorConnexio()\") try { val url = \"jdbc:postgresql://89.36.214.106:5432/geo_ad\" val usuari = \"geo_ad\" val contrasenyes = arrayOf(\"geo0\", \"geo1\", \"geo_ad\") for (i in 0 until contrasenyes.size) { try { con = DriverManager.getConnection(url, usuari, contrasenyes[i]) connectat = true break } catch (ex: SQLException) { if (!ex.getSQLState().equals(\"28P01\")) { // NO \u00e9s un error d'autenticaci\u00f3 throw ex } } } if (connectat) println(\"Connexi\u00f3 efectuada correctament\") else println(\"Error en la contrasenya\") } catch (ex: SQLException) { if (ex.getSQLState().equals(\"08001\")) { println( \"S'ha detectat un problema de connexi\u00f3. Reviseu els cables de xarxa i assegureu-vos que el SGBD est\u00e0 operatiu.\" + \" Si continua sense connectar, aviseu el servei t\u00e8cnic\" ) } else { println( \"S'ha produ\u00eft un error inesperat. Truqueu al servei t\u00e8cnic indicant el seg\u00fcent codi d'error SQL:\" + ex.getSQLState() ) } } catch (ex: ClassNotFoundException) { println(\"No s'ha trobat el controlador JDBC (\" + ex.message + \"). Truqueu al servei t\u00e8cnic\") } finally { try { if (con != null && !con.isClosed()) { con.close() } } catch (ex: SQLException) { throw ex } } }","title":"6.3 - Tractament d'errors en aplicacions JDBC"},{"location":"6__jdbc_avanat/#64-transaccions","text":"Una transacci\u00f3 \u00e9s un conjunt de sent\u00e8ncies SQL d'actualitzaci\u00f3 (INSERT, DELETE, UPDATE) que o b\u00e9 s'executen totes o b\u00e9 no s'executa ninguna. La manera de confirmar les sent\u00e8ncies \u00e9s amb COMMIT , i la manera de rebutjar-les totes \u00e9s ROLLBACK (quedant l'estat com estava abans de comen\u00e7ar la transacci\u00f3). En qualsevol dels dos casos, despr\u00e9s d'executar les sent\u00e8ncies de control COMMIT o ROLLBACK , comen\u00e7ar\u00e0 una transacci\u00f3 nova. JDBC trasllada tamb\u00e9 aquest metodologia al seu API. Per defecte, les connexions JDBC consideren que cada objecte Statement \u00e9s en si mateix una transacci\u00f3. Abans de cada execuci\u00f3 es demana l\u2019inici d\u2019una transacci\u00f3 i al final, si l\u2019execuci\u00f3 t\u00e9 \u00e8xit, s\u2019envia un commit i si no t\u00e9 \u00e8xit, un rollback . Per aix\u00f2 diem que la connexi\u00f3 actua en mode autocommit . Per\u00f2 hi ha una altra manera de funcionar. Els Statements poden treballar sense automatitzar el commit despr\u00e9s de cada execuci\u00f3, canviant la connexi\u00f3 de mode amb el m\u00e8tode setAutoCommit(false) . A partir d\u2019aleshores es consideraran instruccions d\u2019una mateixa transacci\u00f3 totes les sent\u00e8ncies executades entre dues cridades als m\u00e8todes commit o rollback (equivalents JDBC de les instruccions COMMIT i ROLLBACK de SQL). A continuaci\u00f3 tenim un programa en el qual fem una s\u00e8rie de canvis (una modificaci\u00f3 de files i un esborrat) per\u00f2 despr\u00e9s fem un rollback, i per tant no s'haur\u00e0 fet cap de les actualitzacions. \u00c9s sobre la Base de Dades de SQLite Empleats,sqlite , que nom\u00e9s tenia la taula EMPLEAT. Per a mostrar que estem fent els canvis, per\u00f2 que despr\u00e9s ls desfem amb rollback , mostrem un resum en el qual senzillament indiquem el n\u00famero d'empleat i el total dels sous. Pr\u00e8viament ens guardem el estat que tenia l' autocommit , i despr\u00e9s el desactivem. Quan finalitza tot el proc\u00e9s posem autocommit com estava en un principi. Copieu el seg\u00fcent codi en un fitxer Kotlin anomenat Exemple_4_61_Transaccions.kt : package exemples import java.sql.DriverManager import java.sql.Connection fun main(args: Array<String>) { val con = DriverManager.getConnection(\"jdbc:sqlite:Empleats.sqlite\") resumEmpleats(con) // estat inicial val autocommit = con.getAutoCommit() con.setAutoCommit(false) val st = con.createStatement() st.executeUpdate(\"UPDATE EMPLEAT SET sou = sou * 1.05\") st.executeUpdate(\"DELETE FROM EMPLEAT WHERE depart=10\") resumEmpleats(con) // s'han modificat els sous i s'han esborrat dos empleats con.rollback() // desfem els canvis resumEmpleats(con) // hem tornat a l'estat inicial: // no s'ha fet ni l'actualitzaci\u00f3 de sous ni l'esborrat d'empleats con.setAutoCommit(autocommit) con.close() } fun resumEmpleats(c: Connection) { // En el resum traurem el n\u00famero d'empleats i el total de sous val st = c.createStatement() val rs = st.executeQuery(\"SELECT COUNT(*), SUM(sou) FROM EMPLEAT\") rs.next() println(\"Actualment hi ha \" + rs.getInt(1) + \" empleats que cobren un total de \" + rs.getDouble(2) + \" \u20ac\") rs.close() st.close() } La major part de SGBD permeten utilitzar transaccions expl\u00edcites amb qualsevol instrucci\u00f3 SQL, fins i tot alguns SGBD tamb\u00e9 en sent\u00e8ncies DDL ( data definition language ) com CREATE TABLE, etc . Les sent\u00e8ncies de definici\u00f3 modifiquen directament l\u2019estructura de les dades i, per tant, cal anar molt en compte perqu\u00e8 poden provocar danys importants, p\u00e8rdues de dades existents, etc. Per\u00f2 hi ha alguns SGBD com Oracle que no suporten la revocaci\u00f3 de sent\u00e8ncies DDL i en cas d\u2019executar rollback , obtindrem un error indicant que les sent\u00e8ncies DDL no es poden revocar.","title":"6.4 - Transaccions"},{"location":"6__jdbc_avanat/#65-millora-de-rendiment","text":"Un altre aspecte important que mesura la qualitat de les aplicacions \u00e9s l\u2019efici\u00e8ncia amb la qual s\u2019aconsegueix comunicar amb el SGBD. Per optimitzar la connexi\u00f3 \u00e9s important recon\u00e8ixer quins processos poden actuar de coll d\u2019ampolla. En primer lloc, analitzarem la petici\u00f3 de connexi\u00f3 a un SGBD perqu\u00e8 es tracta d\u2019un proc\u00e9s cost\u00f3s per\u00f2 inevitable que cal considerar. En segon lloc, estudiarem les sent\u00e8ncies predefinides, perqu\u00e8 el seu \u00fas facilita la creaci\u00f3 de dades clau i \u00edndexs temporals de manera que siga possible anticipar-se a la demanda o disposar de les dades de forma molt m\u00e9s r\u00e0pida. Temps de vida d'una connexi\u00f3 L\u2019establiment d\u2019una connexi\u00f3 \u00e9s un procediment molt lent, tant a la part client com a la part servidor. A la part client, DriverManager ha de descobrir el controlador correcte d\u2019entre tots els que haja de gestionar. La majoria de vegades les aplicacions treballaran nom\u00e9s amb un \u00fanic controlador, per\u00f2 cal tenir en compte que DriverManager no coneix a priori quina URL de connexi\u00f3 correspon a cada controlador, i per saber-ho envia una petici\u00f3 de connexi\u00f3 a cada controlador que tinga registrat, el controlador que no li retorna error ser\u00e0 el correcte. A la banda servidor, es crear\u00e0 un context espec\u00edfic i s\u2019habilitaran un conjunt de recursos per cada client connectat. \u00c9s a dir, que durant la petici\u00f3 de connexi\u00f3 el SGDB ha de gastar un temps considerable abans de deixar operativa la comunicaci\u00f3 client-servidor. Aquesta elevat cost de temps concentrat en el moment de la petici\u00f3 de connexi\u00f3 fa que ens plantegem si val la pena obrir i tancar la connexi\u00f3 cada vegada que ens toque executar una sent\u00e8ncia SQL, o obrir una connexi\u00f3 al principi de l'aplicaci\u00f3 que tancar\u00edem en finalitzar. Lamentablement no hi ha una \u00fanica resposta, sin\u00f3 que dep\u00e8n de la freq\u00fc\u00e8ncia d\u2019\u00fas de la connexi\u00f3 i el n\u00famero de connexions contra el mateix SGBD. Com en tot, es tracta de trobar el punt d\u2019equilibri. Si el n\u00famero de clients, i per tant de connexions, \u00e9s baix i la freq\u00fc\u00e8ncia d\u2019\u00fas \u00e9s alta, ser\u00e0 preferible mantenir les connexions obertes molt de temps. Per contra, si el n\u00famero de connexions \u00e9s molt alt i la freq\u00fc\u00e8ncia d'\u00fas baixa, el que ser\u00e0 preferible ser\u00e0 obrir i tancar la connexi\u00f3 cada vegada que es necessite. I tamb\u00e9 hi haur\u00e0 una multitud de casos en qu\u00e8 la soluci\u00f3 consistir\u00e0 a mantenir les connexions obertes per\u00f2 no permanentment. Es pot donar un temps de vida a cada connexi\u00f3, o b\u00e9 tancar-les despr\u00e9s de restar inactiva una quantitat determinada de temps, o es pot fer servir el criteri de mantenir un n\u00famero m\u00e0xim de connexions obertes, tancant les m\u00e9s antigues o les m\u00e9s inactives quan se sobrepasse el l\u00edmit. Sent\u00e8ncies predefinides JDBC disposa d\u2019un objecte derivat del Statement que s\u2019anomena PreparedStatement ., a la qual se li passa la sent\u00e8ncia SQL en el moment de crear-lo, no en el moment d'executar la sent\u00e8ncia (com passava amb Statement ). I a m\u00e9s aquesta sent\u00e8ncia pot admetre par\u00e0metres, cosa que ens pot anar molt b\u00e9 en determinades ocasions. Siga com siga, PreparedStatement presenta avantatges sobre el seu antecessor Statement quan ens toque treballar amb sent\u00e8ncies que s'hagen d'executar diverses vegades. La ra\u00f3 \u00e9s que qualsevol sent\u00e8ncia SQL, quan s\u2019envia al SGBD ser\u00e0 compilada abans de ser executada. Utilitzant un objecte Statement , cada vegada que fem una execuci\u00f3 d\u2019una sent\u00e8ncia, ja siga via executeUpdate o b\u00e9 via executeQuery , el SGBD la compilar\u00e0, ja que li arribar\u00e0 en forma de cadena de car\u00e0cters. En canvi, al PreparedStament la sent\u00e8ncia mai varia i per tant es pot compilar i guardar dins del mateix objecte, de manera que les seg\u00fcents vegades que s\u2019execute no caldr\u00e0 compilar-la. Aix\u00f2 reduir\u00e0 sensiblement el temps d\u2019execuci\u00f3. En alguns sistemes gestors, a m\u00e9s, fer servir PreparedStatements pot arribar a suposar m\u00e9s avantatges, ja que utilitzen la seq\u00fc\u00e8ncia de bytes de la sent\u00e8ncia per detectar si es tracta d\u2019una sent\u00e8ncia nova o ja s\u2019ha servit amb anterioritat. D\u2019aquesta manera es propicia que el sistema guarde les respostes en la mem\u00f2ria cach\u00e9, de manera que es puguen lliurar de forma m\u00e9s r\u00e0pida. En el moment de programar, la principal difer\u00e8ncia dels objectes PreparedStatement en relaci\u00f3 als Statement , \u00e9s que en els \u00faltims la sent\u00e8ncia es passa com a par\u00e0metre en el moment d'executar-lo, mentre que en els primers se'ls passa la sent\u00e8ncia SQL predefinida en el moment de crear-lo (no d'executar-lo). Com que la sent\u00e8ncia queda predefinida, ni els m\u00e8todes executeUpdate ni executeQuery requeriran cap par\u00e0metre. \u00c9s a dir, justet al rev\u00e8s que en el Statement . Posem un exemple, en el qual demanem per teclat el nom d'una comarca i una altura, per a traure els pobles de la comarca introdu\u00efda que estan a una altura superior a l'altura introdu\u00efda. Copieu el seg\u00fcent codi en un fitxer Kotlin anomenat Exemple_4_71_Statement.kt : package exemples import java.sql.DriverManager import java.util.Scanner fun main(args: Array<String>) { val con = DriverManager.getConnection(\"jdbc:postgresql://89.36.214.106:5432/geo_ad\", \"geo_ad\", \"geo_ad\") println(\"Introdueix una comarca:\") val com = Scanner(System.`in`).nextLine() println(\"Introdueix una altura:\") val alt = Scanner(System.`in`).nextInt() val st = con.createStatement() // La sent\u00e8ncia no va en el moment de la creaci\u00f3 sin\u00f3 en el d'execuci\u00f3 val rs = st.executeQuery(\"SELECT nom,altura FROM POBLACIO WHERE nom_c='\" + com + \"' AND altura>\" + alt) while (rs.next()) { println(rs.getString(1) + \" (\" +rs.getInt(2) + \" m.)\") } st.close() con.close() } Observeu com per al cas del nom de la comarca, que \u00e9s un String (o millor dit un Varchar), en la sent\u00e8ncia SQL hem de posar una cometa simple (') abans i despr\u00e9s del valor de la comarca, ja que \u00e9s aix\u00ed com s'expressen els Varchar. Resulta un poc inc\u00f2mode. Si utilitzem PreparedStatement , nom\u00e9s haurem de canviar les l\u00ednies 14 i 15. Copieu el seg\u00fcent codi en un fitxer Kotlin anomenat Exemple_4_72_PreparedStatement.kt , i observeu com nom\u00e9s han canviat les l\u00ednies 14 i 15: package exemples import java.sql.DriverManager import java.util.Scanner fun main(args: Array<String>) { val con = DriverManager.getConnection(\"jdbc:postgresql://89.36.214.106:5432/geo_ad\", \"geo_ad\", \"geo_ad\") println(\"Introdueix una comarca:\") val com = Scanner(System.`in`).nextLine() println(\"Introdueix una altura:\") val alt = Scanner(System.`in`).nextInt() val st = con.prepareStatement(\"SELECT nom,altura FROM POBLACIO WHERE nom_c='\" + com + \"' AND altura>\" + alt) val rs = st.executeQuery() // La sent\u00e8ncia no va en el moment de l'execuci\u00f3 sin\u00f3 en el de creaci\u00f3 while (rs.next()) { println(rs.getString(1) + \" (\" +rs.getInt(2) + \" m.)\") } st.close() con.close() } Per\u00f2 anem un pas m\u00e9s enll\u00e0 i anem a utilitzar par\u00e0metres. La utilitzaci\u00f3 de par\u00e0metres, a banda de la comoditat, en pot anar molt b\u00e9 per a previndre errors. Observeu com en els dos exemples anteriors ten\u00edem un problema si el nom de la comarca cont\u00e9 una cometa simple (') com \u00e9s en el cas per exemple de la Vall d'Albaida . Si intentem posar aquesta comarca ens saltar\u00e0 un error, i \u00e9s perqu\u00e8 interpretar\u00e0 la cometa com el final de la cadena Varchar, i no sabr\u00e0 qu\u00e8 \u00e9s Albaida SELECT nom,altura FROM POBLACIO WHERE nom_c='Vall d'Albaida' AND altura=500 La manera de solucionar-ho seria escapar la cometa, o doblar-la (vull dir 2 cometes simples, no doble cometa). Per\u00f2 tamb\u00e9 ens pot anar molt b\u00e9 i molt c\u00f2mode utilitzar par\u00e0metres, com veurem ara. Els par\u00e0metres de la sent\u00e8ncia es marcaran amb el s\u00edmbol d\u2019interrogant (?) i s\u2019identificaran per la posici\u00f3 que ocupen a la sent\u00e8ncia, comen\u00e7ant a comptar des de l\u2019esquerra i a partir del n\u00famero 1. El valor dels par\u00e0metres s\u2019assignar\u00e0 fent servir el m\u00e8tode espec\u00edfic, d\u2019acord amb el tipus de dades a assignar. El nom d'aquestos m\u00e8todes comen\u00e7ar\u00e0 per set i continuar\u00e0 amb el nom del tipus de dades (exemples: setString() , setInt() , setLong() , setBoolean() \u2026). Tots aquestos m\u00e8todes segueixen la mateixa sintaxi: setXXXX(<posicioALaSentenciaSQL>, <valor>) Veiem com quedaria el nostre exemple. Copieu el seg\u00fcent codi en un fitxer Kotlin anomenat Exemple_4_73_PreparedStatement_ambParametres.kt : package exemples import java.sql.DriverManager import java.util.Scanner fun main(args: Array<String>) { val con = DriverManager.getConnection(\"jdbc:postgresql://89.36.214.106:5432/geo_ad\", \"geo_ad\", \"geo_ad\") println(\"Introdueix una comarca:\") val com = Scanner(System.`in`).nextLine() println(\"Introdueix una altura:\") val alt = Scanner(System.`in`).nextInt() val st = con.prepareStatement(\"SELECT nom,altura FROM POBLACIO WHERE nom_c=? AND altura>?\") st.setString(1,com) // Abans d'executar-la s'han d'iniciar els par\u00e0metres st.setInt(2,alt) val rs = st.executeQuery() // La sent\u00e8ncia no va en el moment de l'execuci\u00f3 sin\u00f3 en el de creaci\u00f3 while (rs.next()) { println(rs.getString(1) + \" (\" +rs.getInt(2) + \" m.)\") } st.close() con.close() } Mireu com \u00e9s m\u00e9s c\u00f2mode, perqu\u00e8 en el moment de definir la sent\u00e8ncia (quan creem el PreparedStatement) per a el string no ens hem preocupat de posar la cometa. Ni tampoc en el moment de definir el par\u00e0metre en la l\u00ednia seg\u00fcent. I a m\u00e9s ara no fallar\u00e0 quan posem la comarca Vall d'Albaida Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement CompartirIgual 2.5","title":"6.5 - Millora de rendiment"},{"location":"exercicis/","text":"Exercicis \u00b6 Els seg\u00fcents exercicis, posa'ls tots en un paquet del projecte Tema4 anomenat e xercicis Exercici 4_1 \u00b6 Crea un programa Kotlin anomenat Ex4_1_CreaTaulesRuta.kt que cree les taules necess\u00e0ries per a guardar les dades de les rutes en una Base de Dades SQLite anomenada Rutes.sqlite . Han de ser 2 taules: RUTES : que contindr\u00e0 tota la informaci\u00f3 del conjunt de la ruta. La clau principal s'anomenar\u00e0 num_r (entera). Tamb\u00e9 guardar\u00e0 el nom de la ruta ( nom_r ), desnivell ( desn ) i desnivell acumulat ( desn_ac ). Els tipus d'aquestos tres camps \u00faltims seran de text, enter i enter respectivament. PUNTS : que contindr\u00e0 la informaci\u00f3 dels punts individuals de les rutes. Contindr\u00e0 els camps num_r (n\u00famero de ruta: enter) , num_p (n\u00famero de punt: enter), nom_p (nom del punt: text) , latitud (n\u00famero real) i longitud (n\u00famero real). La clau principal ser\u00e0 la combinaci\u00f3 num_r + num_p . Tindr\u00e0 una clau externa ( num_r ) que apuntar\u00e0 a la clau principal de RUTES . Adjunta tot el projecte, i tamb\u00e9 la Base de Dades Rutes.sqlite (normalment estar\u00e0 dins del projecte) Exercici 4_2 \u00b6 Crea una altre programa anomenat Ex4_2_ PassarRutesObjSQLite.kt que passe les dades del fitxer Rutes.obj a les taules de Rutes.sqlite . Per a major comoditat copiat el fitxer Rutes.obj que vam fer al projecte Tema3 dins d'aquest projecte, a m\u00e9s de les classes Coordenades.kt , PuntGeo.kt i Ruta.kt dins del paquet. Si el paquet s'anomena igual en els dos projectes (jo us havia suggerit exercicis ) no hauria d'haver cap problema. Concretament en el trasvassament d'informaci\u00f3: Per a cada ruta s'ha de considerar el n\u00famero de ruta , que s'anir\u00e0 incrementant, i a m\u00e9s ser\u00e0 la clau principal . La primera ruta ha de ser la n\u00famero 1. A banda han d'anar la resta de camps. Per a cada punt s'ha de guardar el n\u00famero de ruta i el n\u00famero de punt (s'anir\u00e0 incrementant des de 1 per a cada ruta). A banda han d'anar la resta de camps. T'aconselle vivament que abans d'executar les sent\u00e8ncies SQL d'inserci\u00f3, les tragues per pantalla, per veure si la sintaxi \u00e9s correcta. Quan totes siguen correctes, pots substituir l'eixida per l'execuci\u00f3 de les sent\u00e8ncies. Adjunta tot el projecte, i tamb\u00e9 la Base de Dades Rutes.sqlite , que normalment estar\u00e0 situada dins del projecte Exercici 4_3 \u00b6 Crea un programa anomenat Ex4_3_ VisRutes_SQLite.kt , que mostre les rutes amb un aspecte similar a l' Exercici 3_4 , per\u00f2 accedint ara a les dades guardades en Rutes.sqlite : Podr\u00edem mantenir la connexi\u00f3 fins que s'aprete el bot\u00f3 d' Eixir , que \u00e9s quan la tancar\u00edem. Ac\u00ed teniu l'esquelet del programa. import javax.swing.JFrame import java.awt.EventQueue import java.awt.BorderLayout import javax.swing.JPanel import java.awt.FlowLayout import javax.swing.JComboBox import javax.swing.JButton import javax.swing.JTextArea import javax.swing.JLabel class Finestra : JFrame() { init { // Sent\u00e8ncies per a fer la connexi\u00f3 defaultCloseOperation = JFrame.EXIT_ON_CLOSE setTitle(\"JDBC: Visualitzar Rutes\") setSize(450, 450) setLayout(BorderLayout()) val panell1 = JPanel(FlowLayout()) val panell2 = JPanel(BorderLayout()) add(panell1, BorderLayout.NORTH) add(panell2, BorderLayout.CENTER) val llistaRutes = arrayListOf<String>() // Sent\u00e8ncies per a omplir l'ArrayList amb el nom de les rutes val combo = JComboBox<String>(llistaRutes.toTypedArray()) panell1.add(combo) val eixir = JButton(\"Eixir\") panell1.add(eixir) val area = JTextArea() panell2.add(JLabel(\"Llista de punts de la ruta:\"),BorderLayout.NORTH) panell2.add(area,BorderLayout.CENTER) combo.addActionListener() { // Sent\u00e8ncis quan s'ha seleccionat un element del JComboBox // Han de consistir en omplir el JTextArea } eixir.addActionListener(){ // Sent\u00e8ncies per a tancar la connexi\u00f3 i eixir } } } fun main(args: Array<String>) { EventQueue.invokeLater { Finestra().isVisible = true } } Exercici 4_4 \u00b6 En aquest exercici anem a practicar la creaci\u00f3 d'una classe que encapsule pr\u00e0cticament tot el tractament de la Base de Dades, per a fer transparent el desfasament Objecte-Relacional. Per tant aquesta classe ha de ser capa\u00e7 de llegir de les taules convertint a objectes, i tamb\u00e9 guardar la informaci\u00f3 dels objectes en les taules. S'anomenar\u00e0 GestionarRutesBD . En un paquet nou del mateix projecte, anomenat util.bd haureu de fer la classe GestionarRutesBD , que \u00e9s la que encapsular\u00e0 tot. Internament nom\u00e9s tindr\u00e0 una propietat , la de connexi\u00f3 . Tindr\u00e0 els seg\u00fcents m\u00e8todes: El constructor de GestionarRutesBD : establir\u00e0 la connexi\u00f3 amb la Base de Dades Rutes.sqlite (per comoditat en el directori del projecte). Si no existeixen les taules RUTES i PUNTS les haur\u00e0 de crear (podeu utilitzar la sent\u00e8ncia CREATE TABLE IF NOT EXISTS ...) fun close() : tancar\u00e0 la connexi\u00f3. fun inserir(r: Ruta) : Inserir\u00e0 en la BD les dades corresponents a la ruta passada per par\u00e0metre (inicialment s'aconsella \u00fanicament \"imprimir\" les sent\u00e8ncies, per veure si s\u00f3n correctes). El num_r ha de ser el posterior a l'\u00faltima existent, per exemple amb la consulta SELECT MAX(num_r) FROM RUTES fun buscar(i: Int): Ruta? : torna la ruta amb el n\u00famero passat com a par\u00e0metre. fun llistat(): ArrayList : torna un ArrayList de Ruta amb totes les rutes de la Base de Dades. fun esborrar(i: Int) : esborra la ruta amb el n\u00famero passat com a par\u00e0metre (recordeu que els punts de la ruta tamb\u00e9 s'han d'esborrar) Per a provar-lo podeu incorporar l'executable UtilitzarRutesBD.kt . Haur\u00edeu de comentar les l\u00ednies que no s'utilitzen en cada moment. Per exemple, si ja heu aconseguit inserir la ruta, i continueu provant el programa per als m\u00e8todes buscar() i llistat() , comenteu la l\u00ednia gRutes.inserir(r) per a no inserir-la m\u00e9s vegades. fun main(args: Array ) { // Creaci\u00f3 del gestionador val gRutes = GestionarRutesBD() // Inserci\u00f3 d'una nova Ruta val noms = arrayOf( \"Les Useres\", \"Les Torrocelles\", \"Lloma Bernat\", \"Xodos (Mol\u00ed)\", \"El Marinet\", \"Sant Joan\") val latituds = arrayOf(40.158126, 40.196046, 40.219210, 40.248003, 40.250977, 40.251221) val longituds = arrayOf(-0.166962, -0.227611, -0.263560, -0.296690, -0.316947, -0.354052) val punts = arrayListOf () for (i in 0 until 6){ punts.add(PuntGeo(noms[i], Coordenades(latituds[i], longituds[i]))) } gRutes.inserir(Ruta(\"Pelegrins de Les Useres\",896,1738,punts)) // Llistat de totes les rutes for (r in gRutes.llistat()) r?.mostrarRuta() // Buscar una ruta determinada val r2 = gRutes.buscar(2) if (r2 != null) r2.mostrarRuta() gRutes.close() } Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement CompartirIgual 2.5","title":"Exercicis"},{"location":"exercicis/#exercicis","text":"Els seg\u00fcents exercicis, posa'ls tots en un paquet del projecte Tema4 anomenat e xercicis","title":"Exercicis"},{"location":"exercicis/#exercici-4_1","text":"Crea un programa Kotlin anomenat Ex4_1_CreaTaulesRuta.kt que cree les taules necess\u00e0ries per a guardar les dades de les rutes en una Base de Dades SQLite anomenada Rutes.sqlite . Han de ser 2 taules: RUTES : que contindr\u00e0 tota la informaci\u00f3 del conjunt de la ruta. La clau principal s'anomenar\u00e0 num_r (entera). Tamb\u00e9 guardar\u00e0 el nom de la ruta ( nom_r ), desnivell ( desn ) i desnivell acumulat ( desn_ac ). Els tipus d'aquestos tres camps \u00faltims seran de text, enter i enter respectivament. PUNTS : que contindr\u00e0 la informaci\u00f3 dels punts individuals de les rutes. Contindr\u00e0 els camps num_r (n\u00famero de ruta: enter) , num_p (n\u00famero de punt: enter), nom_p (nom del punt: text) , latitud (n\u00famero real) i longitud (n\u00famero real). La clau principal ser\u00e0 la combinaci\u00f3 num_r + num_p . Tindr\u00e0 una clau externa ( num_r ) que apuntar\u00e0 a la clau principal de RUTES . Adjunta tot el projecte, i tamb\u00e9 la Base de Dades Rutes.sqlite (normalment estar\u00e0 dins del projecte)","title":"Exercici 4_1"},{"location":"exercicis/#exercici-4_2","text":"Crea una altre programa anomenat Ex4_2_ PassarRutesObjSQLite.kt que passe les dades del fitxer Rutes.obj a les taules de Rutes.sqlite . Per a major comoditat copiat el fitxer Rutes.obj que vam fer al projecte Tema3 dins d'aquest projecte, a m\u00e9s de les classes Coordenades.kt , PuntGeo.kt i Ruta.kt dins del paquet. Si el paquet s'anomena igual en els dos projectes (jo us havia suggerit exercicis ) no hauria d'haver cap problema. Concretament en el trasvassament d'informaci\u00f3: Per a cada ruta s'ha de considerar el n\u00famero de ruta , que s'anir\u00e0 incrementant, i a m\u00e9s ser\u00e0 la clau principal . La primera ruta ha de ser la n\u00famero 1. A banda han d'anar la resta de camps. Per a cada punt s'ha de guardar el n\u00famero de ruta i el n\u00famero de punt (s'anir\u00e0 incrementant des de 1 per a cada ruta). A banda han d'anar la resta de camps. T'aconselle vivament que abans d'executar les sent\u00e8ncies SQL d'inserci\u00f3, les tragues per pantalla, per veure si la sintaxi \u00e9s correcta. Quan totes siguen correctes, pots substituir l'eixida per l'execuci\u00f3 de les sent\u00e8ncies. Adjunta tot el projecte, i tamb\u00e9 la Base de Dades Rutes.sqlite , que normalment estar\u00e0 situada dins del projecte","title":"Exercici 4_2"},{"location":"exercicis/#exercici-4_3","text":"Crea un programa anomenat Ex4_3_ VisRutes_SQLite.kt , que mostre les rutes amb un aspecte similar a l' Exercici 3_4 , per\u00f2 accedint ara a les dades guardades en Rutes.sqlite : Podr\u00edem mantenir la connexi\u00f3 fins que s'aprete el bot\u00f3 d' Eixir , que \u00e9s quan la tancar\u00edem. Ac\u00ed teniu l'esquelet del programa. import javax.swing.JFrame import java.awt.EventQueue import java.awt.BorderLayout import javax.swing.JPanel import java.awt.FlowLayout import javax.swing.JComboBox import javax.swing.JButton import javax.swing.JTextArea import javax.swing.JLabel class Finestra : JFrame() { init { // Sent\u00e8ncies per a fer la connexi\u00f3 defaultCloseOperation = JFrame.EXIT_ON_CLOSE setTitle(\"JDBC: Visualitzar Rutes\") setSize(450, 450) setLayout(BorderLayout()) val panell1 = JPanel(FlowLayout()) val panell2 = JPanel(BorderLayout()) add(panell1, BorderLayout.NORTH) add(panell2, BorderLayout.CENTER) val llistaRutes = arrayListOf<String>() // Sent\u00e8ncies per a omplir l'ArrayList amb el nom de les rutes val combo = JComboBox<String>(llistaRutes.toTypedArray()) panell1.add(combo) val eixir = JButton(\"Eixir\") panell1.add(eixir) val area = JTextArea() panell2.add(JLabel(\"Llista de punts de la ruta:\"),BorderLayout.NORTH) panell2.add(area,BorderLayout.CENTER) combo.addActionListener() { // Sent\u00e8ncis quan s'ha seleccionat un element del JComboBox // Han de consistir en omplir el JTextArea } eixir.addActionListener(){ // Sent\u00e8ncies per a tancar la connexi\u00f3 i eixir } } } fun main(args: Array<String>) { EventQueue.invokeLater { Finestra().isVisible = true } }","title":"Exercici 4_3"},{"location":"exercicis/#exercici-4_4","text":"En aquest exercici anem a practicar la creaci\u00f3 d'una classe que encapsule pr\u00e0cticament tot el tractament de la Base de Dades, per a fer transparent el desfasament Objecte-Relacional. Per tant aquesta classe ha de ser capa\u00e7 de llegir de les taules convertint a objectes, i tamb\u00e9 guardar la informaci\u00f3 dels objectes en les taules. S'anomenar\u00e0 GestionarRutesBD . En un paquet nou del mateix projecte, anomenat util.bd haureu de fer la classe GestionarRutesBD , que \u00e9s la que encapsular\u00e0 tot. Internament nom\u00e9s tindr\u00e0 una propietat , la de connexi\u00f3 . Tindr\u00e0 els seg\u00fcents m\u00e8todes: El constructor de GestionarRutesBD : establir\u00e0 la connexi\u00f3 amb la Base de Dades Rutes.sqlite (per comoditat en el directori del projecte). Si no existeixen les taules RUTES i PUNTS les haur\u00e0 de crear (podeu utilitzar la sent\u00e8ncia CREATE TABLE IF NOT EXISTS ...) fun close() : tancar\u00e0 la connexi\u00f3. fun inserir(r: Ruta) : Inserir\u00e0 en la BD les dades corresponents a la ruta passada per par\u00e0metre (inicialment s'aconsella \u00fanicament \"imprimir\" les sent\u00e8ncies, per veure si s\u00f3n correctes). El num_r ha de ser el posterior a l'\u00faltima existent, per exemple amb la consulta SELECT MAX(num_r) FROM RUTES fun buscar(i: Int): Ruta? : torna la ruta amb el n\u00famero passat com a par\u00e0metre. fun llistat(): ArrayList : torna un ArrayList de Ruta amb totes les rutes de la Base de Dades. fun esborrar(i: Int) : esborra la ruta amb el n\u00famero passat com a par\u00e0metre (recordeu que els punts de la ruta tamb\u00e9 s'han d'esborrar) Per a provar-lo podeu incorporar l'executable UtilitzarRutesBD.kt . Haur\u00edeu de comentar les l\u00ednies que no s'utilitzen en cada moment. Per exemple, si ja heu aconseguit inserir la ruta, i continueu provant el programa per als m\u00e8todes buscar() i llistat() , comenteu la l\u00ednia gRutes.inserir(r) per a no inserir-la m\u00e9s vegades. fun main(args: Array ) { // Creaci\u00f3 del gestionador val gRutes = GestionarRutesBD() // Inserci\u00f3 d'una nova Ruta val noms = arrayOf( \"Les Useres\", \"Les Torrocelles\", \"Lloma Bernat\", \"Xodos (Mol\u00ed)\", \"El Marinet\", \"Sant Joan\") val latituds = arrayOf(40.158126, 40.196046, 40.219210, 40.248003, 40.250977, 40.251221) val longituds = arrayOf(-0.166962, -0.227611, -0.263560, -0.296690, -0.316947, -0.354052) val punts = arrayListOf () for (i in 0 until 6){ punts.add(PuntGeo(noms[i], Coordenades(latituds[i], longituds[i]))) } gRutes.inserir(Ruta(\"Pelegrins de Les Useres\",896,1738,punts)) // Llistat de totes les rutes for (r in gRutes.llistat()) r?.mostrarRuta() // Buscar una ruta determinada val r2 = gRutes.buscar(2) if (r2 != null) r2.mostrarRuta() gRutes.close() } Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement CompartirIgual 2.5","title":"Exercici 4_4"}]}